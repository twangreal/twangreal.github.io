<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>twangreal的博客</title>
    <link>https://twangreal.github.io/</link>
    <description>Recent content on twangreal的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 18 Mar 2020 16:05:22 +0800</lastBuildDate>
    
	<atom:link href="https://twangreal.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Week5_其他</title>
      <link>https://twangreal.github.io/post/week5_%E5%85%B6%E4%BB%96/</link>
      <pubDate>Wed, 18 Mar 2020 16:05:22 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/week5_%E5%85%B6%E4%BB%96/</guid>
      <description>一、基类和派生类指针的互相转换 （1）公有派生的情况下,派生类对象的指针可以直接赋值给基类指针
（2）基类的指针不能赋值给派生类的指针，除非强制类型转换，
Base * ptrBase = &amp;amp;objDerived;//本来就指向一个派生类的对象 Derived *ptrDerived = (Derived * ) ptrBase; 注意 ：需要保证被转换的基类指针本来就指向一个派生类的对象。
注意2 ：即便基类指针指向的是一个派生类对象，也不能通过基类指针访问基类没有而派生类中有的成员。
二、派生类和赋值运算符 如果基类重载了赋值运算符= 而派生类没有，
那么在派生类对象之间赋值，或用派生类对象对基类对象进行赋值时，
其中基类部分的赋值操作时调用被基类重载的“=”完成的。</description>
    </item>
    
    <item>
      <title>Week5_公有继承的赋值兼容规则</title>
      <link>https://twangreal.github.io/post/week5_%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF%E7%9A%84%E8%B5%8B%E5%80%BC%E5%85%BC%E5%AE%B9%E8%A7%84%E5%88%99/</link>
      <pubDate>Wed, 18 Mar 2020 15:24:10 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/week5_%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF%E7%9A%84%E8%B5%8B%E5%80%BC%E5%85%BC%E5%AE%B9%E8%A7%84%E5%88%99/</guid>
      <description>一、public继承 class base { }; class derived : public base { };//public-&amp;gt;公有派生，还可以写private、protected，但不常用 base b; derived d; public继承的赋值兼容规则：
1） 派生类的对象可以赋值给基类对象
b = d;//派生类对象d中包含的基类对象赋值给b2） 派生类对象可以初始化基类引用
base &amp;amp; br = d;//br引用了派生类对象d中包含的基类对象3） 派生类对象的地址可以赋值给基类指针
base * pb = &amp;amp; d;//基类指针指向了派生类对象d中包含的基类对象注意：如果派生方式是 private或protected，则上述三条不可行，下面的这条结论也不成立。
在公有派生的情况下，可以说，派生类对象也是基类对象，任何本该出现基类对象的地方，如果出现的是派生类对象，也是没有问题的。
二、protected继承和private继承 class base { }; class derived : protected base { }; base b; derived d; /*protected继承时，基类的public成员和protected成员成为派生类的protected成员。 • private继承时，基类的public成员成为派生类的private成员，基类的protected成员成 为派生类的不可访问成员。 • protected和private继承不是“是”的关系。*///待定 三、直接基类和间接基类（多层次的派生） (1)类A派生类B，类B派生类C，类C派生类D，……A &amp;ndash;&amp;gt; B &amp;ndash;&amp;gt; C &amp;ndash;&amp;gt; D
– 类A是类B的直接基类
– 类B是类C的直接基类，类A是类C的间接基类</description>
    </item>
    
    <item>
      <title>Week5_派生类的构造函数</title>
      <link>https://twangreal.github.io/post/week5_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 18 Mar 2020 14:52:10 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/week5_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</guid>
      <description>一、构造函数 class Bug { private : int nLegs; int nColor; public: int nType; Bug ( int legs, int color); void PrintBug (){ }; }; class FlyBug: public Bug // FlyBug是Bug的派生类 { int nWings; public: FlyBug( int legs,int color, int wings); }; Bug::Bug( int legs, int color) { nLegs = legs; nColor = color; } //错误的FlyBug构造函数 FlyBug::FlyBug ( int legs,int color, int wings) { nLegs = legs; // 不能访问**nLegs是私有成员** 	nColor = color; // 不能访问**nColor是私有成员** 	nType = 1; // ok**nType是公有成员** 	nWings = wings; } //正确的FlyBug构造函数： FlyBug::FlyBug ( int legs, int color, int wings):Bug( legs, color)//初始化列表中， {	//调用基类的构造函数 nWings = wings; } int main() { FlyBug fb ( 2,3,4); fb.</description>
    </item>
    
    <item>
      <title>Week5_覆盖和保护成员</title>
      <link>https://twangreal.github.io/post/week5_%E8%A6%86%E7%9B%96%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%88%90%E5%91%98/</link>
      <pubDate>Wed, 18 Mar 2020 14:30:02 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/week5_%E8%A6%86%E7%9B%96%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%88%90%E5%91%98/</guid>
      <description>覆盖 一、覆盖 派生类可以定义一个和基类成员同名的成员，这叫覆盖。
在派生类中访问这类成员时，缺省的情况是访问派生类中定义的成员。要在派生类中访问由基类定义的同名成员时，要使用作用域符号:: 。
基类和派生类有同名成员的情况：
//**一般来说，基类和派生类不定义同名成员变量。**定义同名成员函数是常见的。 class base { int j; public: int i; void func(); }; class derived :public base{ public: int i; void access(); void func(); }; void derived::access() { j = 5; //error 	i = 5; //引用的是派生类的 i 	base::i = 5; //引用的是基类的 i 	func(); //派生类的 	base::func(); //基类的 } derived obj; obj.i = 1; obj.base::i = 1; //obj占用的存储空间: //Base::j //Base::i //i 二、类的保护成员 另一种存取权限说明符：protected</description>
    </item>
    
    <item>
      <title>Week5_继承和复合关系</title>
      <link>https://twangreal.github.io/post/week5_%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%8D%E5%90%88%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Tue, 17 Mar 2020 17:40:07 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/week5_%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%8D%E5%90%88%E5%85%B3%E7%B3%BB/</guid>
      <description>一、类之间的两种关系 继承：“是” 关系。
– 基类 A，B是基类A的派生类。
– 逻辑上要求：“一个B对象也是一个A对象”。
复合：“有” 关系。
– 类C中“有”成员变量k，k是类D的对象，则C和D是复合关系。
– 一般逻辑上要求：“D对象是C对象的固有属性或组成部分”。
PS.则C为封闭类
二、继承关系的使用 写了一个 CMan 类代表男人
后来又发现需要一个CWoman类来代表女人
CWoman类和CMan类有共同之处，就让CWoman类从CMan类派生而来，是否合适？
是不合理的!
因为“一个女人也是一个男人”从逻辑上不成立!
好的做法是概括男人和女人共同特点，
写一个 CHuman类，代表“人”, 然后CMan和CWoman都从CHuman派生。
三、复合关系的使用 （1）几何形体程序中，需要写“点”类，也需要写“圆”类，两者的关系就是复合关系 &amp;mdash;- 每一个“圆”对象里都包含(有)一个“点”对象，这个“点”对象就是圆心。
class CPoint { double x,y; friend class CCircle; //便于Ccirle类操作其圆心 }; class CCircle { double r; CPoint center; }; （2）如果要写一个小区养狗管理程序，需要写一个“业主”类，还需要写一个“狗”类。 而狗是有 “主人” 的，主人当然是业主(假定狗只有一个主人，但一个业主可以有最多10条狗）
//！错误，循环定义！ class CDog; class CMaster { CDog dogs[10]; }; class CDog { CMaster m; }; 注意：避免循环定义的方法是 在一个类中使用另一个类的指针，而不是对象作为成员变量。</description>
    </item>
    
    <item>
      <title>week5_继承与派生</title>
      <link>https://twangreal.github.io/post/week5_%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/</link>
      <pubDate>Tue, 17 Mar 2020 16:03:51 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/week5_%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/</guid>
      <description>继承与派生 一、基本概念 1.继承：在定义一个新的类B时，如果该类与某个已有的类A相似(指的是B拥有A的全部特点)，那么就可以把A作为一个基类，而把B作为基类的一个派生类(也称子类)。
​	a.派生类是通过对基类进行修改和扩充得到的。在派生类中，可以扩充新的成员变量和成员函数。
​	b.派生类一经定义后，可以独立使用，不依赖于基类。
2.派生类拥有基类的全部成员函数和成员变量，不论是private、protected、public 。
​	在派生类的各个成员函数中，不能访问基类中的private成员。
//派生类的写法class 派生类名：public 基类名{};//示例class CStudent {private:string sName;int nAge;public:bool IsThreeGood() { };void SetName( const string &amp;amp; name ) { sName = name; }//......}; class CUndergraduateStudent: public CStudent {private: int nDepartment;public:bool IsThreeGood() { ...... }; //覆盖，相同函数名	bool CanBaoYan() { .... };}; // 派生类的写法是：类名: public 基类名class CGraduatedStudent:public CStudent {private:int nDepartment;char szMentorName[20];public:int CountSalary() { .</description>
    </item>
    
    <item>
      <title>Week4思考题</title>
      <link>https://twangreal.github.io/post/week4sikaoti/</link>
      <pubDate>Mon, 16 Mar 2020 21:25:51 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/week4sikaoti/</guid>
      <description>第四周 运算符重载 &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; MOOC程序设计与算法（三） 4-2 为什么复制构造函数中不需要下面几条语句？ if(str==s.str)return;if(str)delete [] str;答：复制构造函数作用于初始化刚生成的对象，其中的指针str还没有指向任何空间。
4-3 长度可变的整型数组类 每次在数组尾部添加一个元素都要重新分配内存并且复制原有内容，效率低下，有什么办法能够加快添加元素的速度？ 答：预先多分配一些存储空间，例如在用于初始化对象的构造函数中，分配size+32的空间大小，那么在后续插入的32个元素都不用重新分配空间。
PS.可以参考vector容器的实现 vector//待续。。。。。。</description>
    </item>
    
    <item>
      <title>Week4作业题错误点</title>
      <link>https://twangreal.github.io/post/week4zouye/</link>
      <pubDate>Mon, 16 Mar 2020 17:19:51 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/week4zouye/</guid>
      <description>第四周 Week4运算符重载 MOOC程序设计与算法（三） 001：MyString 1.动态内存分配，字符串，新建内存空间的时候，大小size要+1（&#39;\0&amp;rsquo;），用memcpy拷贝要把&amp;rsquo;\0&#39;拷进去，或者用strcpy
2.浅拷贝和深拷贝
​	a.复制构造函数
​	b.赋值运算符=（需要重载）
​	c.自定义复制函数（比如Copy()）
​	d.动态分配一片新的内存空间，复制
PS.(问题)memcpy和strcpy比较 strcpy和memcpy主要有以下3方面的区别：
(1)复制的内容不同。
strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。
(2)复制的方法不同。
strcpy不需要指定长度，只用于字符串复制，不仅复制字符串内容，还复制字符串的结束符(&#39;\0&amp;rsquo;)。它遇到结束 符&amp;rdquo;\0&amp;quot;结束，容易溢出。memcpy则是根据其第3个参数决定复制的长度。
(3)用途不同。
通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy
原型和实现： strcpy函数原型是：char* strcpy(char* dest, const char* src);
char * strcpy(char * dest, const char * src) // 实现src到dest的复制{if ((src == NULL) || (dest == NULL)) //判断参数src和dest的有效性{return NULL;}char *strdest = dest; //保存目标字符串的首地址 while ((*strDest++ = *strSrc++)!=&amp;#39;\0&amp;#39;); //把src字符串的内容复制到dest下 return strdest;}memset实现：</description>
    </item>
    
    <item>
      <title>week3知识点总结</title>
      <link>https://twangreal.github.io/post/week3/</link>
      <pubDate>Fri, 13 Mar 2020 14:20:51 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/week3/</guid>
      <description>第三周 知识点 一、this指针 ​ 成员函数中用于指向当前对象的指针；静态成员函数中没有this指针。
二、静态成员变量 ​ 1.只有一份，所有同类对象共享；
​ 2.必须在定义类的文件中，对静态成员变量进行一次声明或初始化；//（重要）
​ 3.静态成员变量本质上是全局变量；
​ 4.静态成员函数本上是全局函数；
​ 5.静态成员函数中不能访问非静态成员变量，也不能调用非静态成员函数；
注意 ：关于静态成员变量的 初始化，不是静态成员变量是public还是private还是protected都是在类外初始化，没有影响；但是对于静态成员变量的访问、值的修改 和public还是private还是protected有关。
三、成员对象和封闭类 一个类的成员变量是另一个类的对象，则该类为封闭类。
1.初始化：构造函数，初始化列表（建议）
2.封闭类构造函数和析构函数执行顺序：构造先成员对象后封闭类，析构先封闭类后成员对象
3.封闭类用默认复制构造函数（非自定义）初始化对象时，成员对象也会自动调用其所属类的复制构造函数来初始化
四、常量对象、常量成员函数 常量对象const A a；//原则：不允许修改对象的成员变量
常量成员函数，原则：不允许修改当前对象
基于这样的原则，可以方便记忆这几条特点：
1.常量对象只能调用 构造函数，析构函数，常量成员函数
2.常量成员函数不能调用同类非常量成员函数，可以调用静态成员函数（因为静态成员函数不属于某个特定对象，所以不会修改常量对象，）
PS1. 常量成员函数定义 T 函数名() const {return ;//函数体}PS2.常量成员函数的重载 ​	相同的函数名，一个常量一个非常量，非常量对象调用非常量的，常量对象调用常量的。
PS3.常量型成员变量和引用型成员变量必须用构造函数的初始化列表方式初始化，且常量型成员变量的值一旦初始化后不能再改变P55 五、友元 声明友元可以让其他类或非成员函数调用私有变量。
1.全局函数，其他类的成员函数（非私有）
2.其他类
注意：友元关系不能传递，不能继承（也不相互，即A声明B为自己的友元，则B是A的友元，A不是B的友元）</description>
    </item>
    
    <item>
      <title>week3 NO.5</title>
      <link>https://twangreal.github.io/post/mssj_beizhan/</link>
      <pubDate>Thu, 12 Mar 2020 23:42:51 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/mssj_beizhan/</guid>
      <description>第三周 作业第5题 魔兽世界之一：备战 #include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;struct headquarter{public:int life;int number;};headquarter red;headquarter blue;struct dragon{public:static int strength;static int red_num;static int blue_num;dragon(char c){if(c==0){++dragon::red_num;++red.number;}else{++dragon::blue_num;++blue.number;}}};struct ninja{public:static int strength;static int red_num;static int blue_num;ninja(char c){if(c==0){++ninja::red_num;++red.number;}else{++ninja::blue_num;++blue.</description>
    </item>
    
    <item>
      <title>week3 NO.4</title>
      <link>https://twangreal.github.io/post/zhegezhizhen/</link>
      <pubDate>Thu, 12 Mar 2020 17:49:51 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/zhegezhizhen/</guid>
      <description>第三周 作业第4题 这个指针哪来的 #include &amp;lt;iostream&amp;gt;using namespace std;struct A{int v;A(int vv):v(vv) { }// 在此处补充你的代码 A * getPointer() const{return this;//this指向的是常量a，即返回的是const A类型的对象的地址，getPointer前为const A * }//补充代码};int main(){int i;int * j= &amp;amp;i;const int *k = j;const A a(10);//由于这个对象a为常量，所以下面它调用的getPointer就要求是常量成员函数	const A * p = a.getPointer();//指向常量的指针p，这就要求a.getPointer为 类A对象的地址/指向类A对象的指针q，而getPointer是常量成员函数	cout &amp;lt;&amp;lt; p-&amp;gt;v &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>第十二、十三周</title>
      <link>https://twangreal.github.io/post/%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%8D%81%E4%B8%89%E5%91%A8/</link>
      <pubDate>Wed, 11 Mar 2020 16:29:51 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%8D%81%E4%B8%89%E5%91%A8/</guid>
      <description>第十二、十三周学习总结 MOOC程序设计与算法（一） 一、知识点 1.STL(standard template library) sort排序 :
常用格式 sort(数组名+n1,数组名+n2);
作用：对一个数组排序，默认排序方式——从小到大
实例：int a[4]={5,6,8,9};sort(a,a+4);
从大到小：sort(数组名+n1,数组名+n2,greater&amp;lt;T&amp;gt;());//T为数组的类型
进阶——自定义规则排序：sort(数组名+n1,数组名+n2,自定义规则名());//T为数组的类型
自定义规则形式：
struct 规则名{bool operator() (const T &amp;amp;a1, const T &amp;amp;a2 ) const{return ;//这里定义排序规则	}};//示例1：从大到小排struct Rule{bool operator() (const int &amp;amp;a1, const int &amp;amp;a2 ) const{return a1&amp;gt;a2;//a1的值大于a2，返回true，表示a1能排在a2前；否则返回法拉瑟，表示a1不能排在a2前 }};//示例2：有两个成员变量的结构组成的数组排序，姓名、年龄，年龄大的排前面，年龄相同的姓名字典序小的排前面struct P{char name[10];int age;};//结构Pstruct Rule{bool operator() (const P &amp;amp;a1, const P &amp;amp;a2 ) const{if(a1.</description>
    </item>
    
    <item>
      <title>平衡二叉树</title>
      <link>https://twangreal.github.io/post/blogtest/</link>
      <pubDate>Fri, 11 Oct 2019 16:29:51 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/blogtest/</guid>
      <description>关于平衡二叉树是不是二叉排序树 答案是 是的。
平衡二叉树的定义 平衡二叉树或者是一棵空树，或者是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树的高度差的绝对值不超过1 。
从这个定义看，平衡二叉树应当是二叉树，不一定是二叉排序树，但是： “我们通常将平衡二叉树默认为二叉排序树，故平衡二叉树的概念包含两个方面：平衡、有序 ”。1
AVL树 AVL树：AVL(Adelson-Velskii 和 Landis)树是带有平衡条件的二叉查找树（即二叉排序树），一棵AVL树是其每个结点的左子树和右子树的高度最多差1的二叉查找树。2
其实我们通常说的 平衡二叉树 指的就是AVL树，所以是二叉排序树。
  引用自《2020年计算机专业基础综合考试真题思路分析》 &amp;#x21a9;&amp;#xfe0e;
 引用自《数据结构与算法分析——C语言描述》, Mark Allen Weiss. &amp;#x21a9;&amp;#xfe0e;
   </description>
    </item>
    
  </channel>
</rss>