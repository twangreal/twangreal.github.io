<!doctype html>
<html lang="en-us">
  <head>
    <title>Week1-3知识点整理 // twangreal的博客</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.67.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="twangreal" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://twangreal.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Week1-3知识点整理"/>
<meta name="twitter:description" content="1.引用 （1）引用类型要求与之绑定的对象类型严格匹配。（两个例外）
例外：
  继承、多态——引用类型为基类，绑定对象类型为派生类；
  初始化常量的引用时允许用任意表达式作为初始值，只要该表达式的结果能转化成引用的类型即可。
  int i = 42; const int &amp;r1 = i; // 正确 const int &amp;r2 = 42; // 正确 const int &amp;r3 = r1 * 2; // 正确  double dval = 3.14; // int &amp;a = dval; // 编译错误，因为普通引用的类型要与对象类型一致 const int &amp;b = dval; // 编译正确 //c&#43;&#43;的自动类型转换机制中，当用一个double去初始化int时，会舍弃掉小数转换为int。在上面的例子中，编译后的代码实际是这样的： double dval = 3.14; const int temp = dval; // 由double生成了一个临时的整形常量 const int &amp;b = temp; // 让b绑定这个临时量 引用自"/>

    <meta property="og:title" content="Week1-3知识点整理" />
<meta property="og:description" content="1.引用 （1）引用类型要求与之绑定的对象类型严格匹配。（两个例外）
例外：
  继承、多态——引用类型为基类，绑定对象类型为派生类；
  初始化常量的引用时允许用任意表达式作为初始值，只要该表达式的结果能转化成引用的类型即可。
  int i = 42; const int &amp;r1 = i; // 正确 const int &amp;r2 = 42; // 正确 const int &amp;r3 = r1 * 2; // 正确  double dval = 3.14; // int &amp;a = dval; // 编译错误，因为普通引用的类型要与对象类型一致 const int &amp;b = dval; // 编译正确 //c&#43;&#43;的自动类型转换机制中，当用一个double去初始化int时，会舍弃掉小数转换为int。在上面的例子中，编译后的代码实际是这样的： double dval = 3.14; const int temp = dval; // 由double生成了一个临时的整形常量 const int &amp;b = temp; // 让b绑定这个临时量 引用自" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://twangreal.github.io/post/week1-3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" />
<meta property="article:published_time" content="2020-04-13T19:12:05+08:00" />
<meta property="article:modified_time" content="2020-04-13T19:12:05+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://twangreal.github.io/"><img class="app-header-avatar" src="/personal/cyberpunk1.jpg" alt="twangreal" /></a>
      <h1>twangreal的博客</h1>
      <p>面向对象程序设计基于三个基本概念：数据抽象、继承和动态绑定。  后台开发：编程语言、编译调试、网络通信、常用类库、HTTP协议、进程通信。</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/twangreal" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Week1-3知识点整理</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Apr 13, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div></div>
    </header>
    <div class="post-content">
      <h4 id="1引用">1.引用</h4>
<p>（1）引用类型要求与之绑定的对象类型严格匹配。（两个例外）</p>
<p>例外：</p>
<ol>
<li>
<p>继承、多态——引用类型为基类，绑定对象类型为派生类；</p>
</li>
<li>
<p>初始化常量的引用时允许用任意表达式作为初始值，只要该表达式的结果能转化成引用的类型即可。</p>
</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>r1 <span style="color:#f92672">=</span> i;      <span style="color:#75715e">// 正确
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>r2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;     <span style="color:#75715e">// 正确
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>r3 <span style="color:#f92672">=</span> r1 <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>; <span style="color:#75715e">// 正确
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">double</span> dval <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.14</span>;
<span style="color:#75715e">// int &amp;a = dval;    // 编译错误，因为普通引用的类型要与对象类型一致
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>b <span style="color:#f92672">=</span> dval; <span style="color:#75715e">// 编译正确
</span><span style="color:#75715e">//c++的自动类型转换机制中，当用一个double去初始化int时，会舍弃掉小数转换为int。在上面的例子中，编译后的代码实际是这样的：
</span><span style="color:#75715e"></span><span style="color:#66d9ef">double</span> dval <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.14</span>;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> dval; <span style="color:#75715e">// 由double生成了一个临时的整形常量
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>b <span style="color:#f92672">=</span> temp;   <span style="color:#75715e">// 让b绑定这个临时量
</span></code></pre></div><p><a href="https://blog.csdn.net/Colsum/article/details/79095462">引用自</a></p>
<p>（2）引用初始化引用，绑定的是同一个变量</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> a<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>b <span style="color:#f92672">=</span> a;
<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>c <span style="color:#f92672">=</span> b;<span style="color:#75715e">//b 和 c 都是绑定了变量 a
</span></code></pre></div><p>（3）强制类型转换</p>
<p>p9 强制类型转换（char &amp;）后用于初始化引用。// <strong>注意：慎用！</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> cc <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span>;
    <span style="color:#66d9ef">char</span> <span style="color:#f92672">&amp;</span>r <span style="color:#f92672">=</span> cc;<span style="color:#75715e">//error
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">&amp;</span>r2 <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span>) cc;<span style="color:#75715e">//error
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">&amp;</span>r3 <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">&amp;</span>) cc;
    r3 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;b&#39;</span>;
    printf(<span style="color:#e6db74">&#34;%c&#34;</span>,cc);
    printf(<span style="color:#e6db74">&#34;%c&#34;</span>,r3);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}<span style="color:#75715e">//输出：ab
</span></code></pre></div><p><strong>为什么？</strong> r3 绑定的是谁？</p>
<p><img src="https://twangreal.github.io/C++_image/bind_who.jpg" alt="疑惑"></p>
<p>//。。。。C++primer 第5版 P55</p>
<p>（4）引用和指针</p>
<p><img src="https://twangreal.github.io/C++_image/referencAnaPointer.jpg" alt="bijiao"></p>
<h4 id="2内联函数inline函数缺省函数重载">2.内联函数inline、函数缺省、函数重载</h4>
<p>只能最右连续若干个参数缺省。</p>
<h4 id="3动态内存分配">3.动态内存分配</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">T <span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> T;
<span style="color:#66d9ef">delete</span> p;
T <span style="color:#f92672">*</span> p2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> T[len];
<span style="color:#66d9ef">delete</span> [] p2;
</code></pre></div><h5 id="注意">注意：</h5>
<ol>
<li>delete的指针必须是指向动态内存分配的指针；</li>
<li>在delete 释放内存空间后，指针仍指向那片空间，并不安全，所有在delete后加上 <code>p=nullptr</code>，让指针变成空指针。</li>
</ol>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
