<!doctype html>
<html lang="en-us">
  <head>
    <title>第十二、十三周 // twangreal的博客</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.67.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="twangreal" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://twangreal.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="第十二、十三周"/>
<meta name="twitter:description" content="第十二、十三周学习总结 MOOC程序设计与算法（一） 一、知识点 1.STL(standard template library) sort排序 :
常用格式 sort(数组名&#43;n1,数组名&#43;n2);
作用：对一个数组排序，默认排序方式——从小到大
实例：int a[4]={5,6,8,9};sort(a,a&#43;4);
从大到小：sort(数组名&#43;n1,数组名&#43;n2,greater&lt;T&gt;());//T为数组的类型
进阶——自定义规则排序：sort(数组名&#43;n1,数组名&#43;n2,自定义规则名());//T为数组的类型
自定义规则形式：
struct 规则名{bool operator() (const T &amp;a1, const T &amp;a2 ) const{return ;//这里定义排序规则	}};//示例1：从大到小排struct Rule{bool operator() (const int &amp;a1, const int &amp;a2 ) const{return a1&gt;a2;//a1的值大于a2，返回true，表示a1能排在a2前；否则返回法拉瑟，表示a1不能排在a2前 }};//示例2：有两个成员变量的结构组成的数组排序，姓名、年龄，年龄大的排前面，年龄相同的姓名字典序小的排前面struct P{char name[10];int age;};//结构Pstruct Rule{bool operator() (const P &amp;a1, const P &amp;a2 ) const{if(a1."/>

    <meta property="og:title" content="第十二、十三周" />
<meta property="og:description" content="第十二、十三周学习总结 MOOC程序设计与算法（一） 一、知识点 1.STL(standard template library) sort排序 :
常用格式 sort(数组名&#43;n1,数组名&#43;n2);
作用：对一个数组排序，默认排序方式——从小到大
实例：int a[4]={5,6,8,9};sort(a,a&#43;4);
从大到小：sort(数组名&#43;n1,数组名&#43;n2,greater&lt;T&gt;());//T为数组的类型
进阶——自定义规则排序：sort(数组名&#43;n1,数组名&#43;n2,自定义规则名());//T为数组的类型
自定义规则形式：
struct 规则名{bool operator() (const T &amp;a1, const T &amp;a2 ) const{return ;//这里定义排序规则	}};//示例1：从大到小排struct Rule{bool operator() (const int &amp;a1, const int &amp;a2 ) const{return a1&gt;a2;//a1的值大于a2，返回true，表示a1能排在a2前；否则返回法拉瑟，表示a1不能排在a2前 }};//示例2：有两个成员变量的结构组成的数组排序，姓名、年龄，年龄大的排前面，年龄相同的姓名字典序小的排前面struct P{char name[10];int age;};//结构Pstruct Rule{bool operator() (const P &amp;a1, const P &amp;a2 ) const{if(a1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://twangreal.github.io/post/%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%8D%81%E4%B8%89%E5%91%A8/" />
<meta property="article:published_time" content="2020-03-11T16:29:51+08:00" />
<meta property="article:modified_time" content="2020-03-11T16:29:51+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://twangreal.github.io/"><img class="app-header-avatar" src="/personal/cyberpunk1.jpg" alt="twangreal" /></a>
      <h1>twangreal的博客</h1>
      <p>面向对象程序设计基于三个基本概念：数据抽象、继承和动态绑定。  后台开发：编程语言、编译调试、网络通信、常用类库、HTTP协议、进程通信。</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/twangreal" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">第十二、十三周</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Mar 11, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div></div>
    </header>
    <div class="post-content">
      <h2 id="第十二十三周学习总结">第十二、十三周学习总结</h2>
<h3 id="mooc程序设计与算法一">MOOC程序设计与算法（一）</h3>
<h4 id="一知识点">一、知识点</h4>
<h5 id="1stlstandard-template-library">1.STL(standard template library)</h5>
<p><strong>sort排序  :</strong></p>
<p>常用格式   <code>sort(数组名+n1,数组名+n2);</code></p>
<p>作用：对一个数组排序，默认排序方式——从小到大</p>
<p>实例：<code>int a[4]={5,6,8,9}; sort(a,a+4);</code></p>
<p>从大到小：<code>sort(数组名+n1,数组名+n2,greater&lt;T&gt;());//T为数组的类型</code></p>
<p>进阶——自定义规则排序：sort(数组名+n1,数组名+n2,自定义规则名());//T为数组的类型</p>
<p><strong>自定义规则形式</strong>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">struct</span> <span style="color:#960050;background-color:#1e0010">规则名</span>{
	<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">operator</span>() (<span style="color:#66d9ef">const</span> T <span style="color:#f92672">&amp;</span>a1, <span style="color:#66d9ef">const</span> T <span style="color:#f92672">&amp;</span>a2 ) <span style="color:#66d9ef">const</span>{
		<span style="color:#66d9ef">return</span> ;<span style="color:#75715e">//这里定义排序规则
</span><span style="color:#75715e"></span>	}
};
<span style="color:#75715e">//示例1：从大到小排
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Rule</span>{
    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">operator</span>() (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>a1, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>a2 ) <span style="color:#66d9ef">const</span>{
        <span style="color:#66d9ef">return</span> a1<span style="color:#f92672">&gt;</span>a2;<span style="color:#75715e">//a1的值大于a2，返回true，表示a1能排在a2前；否则返回法拉瑟，表示a1不能排在a2前
</span><span style="color:#75715e"></span>    }
};
<span style="color:#75715e">//示例2：有两个成员变量的结构组成的数组排序，姓名、年龄，年龄大的排前面，年龄相同的姓名字典序小的排前面
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">P</span>{
    <span style="color:#66d9ef">char</span> name[<span style="color:#ae81ff">10</span>];
    <span style="color:#66d9ef">int</span> age;
};<span style="color:#75715e">//结构P
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Rule</span>{
    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">operator</span>() (<span style="color:#66d9ef">const</span> P <span style="color:#f92672">&amp;</span>a1, <span style="color:#66d9ef">const</span> P <span style="color:#f92672">&amp;</span>a2 ) <span style="color:#66d9ef">const</span>{
        <span style="color:#66d9ef">if</span>(a1.age<span style="color:#f92672">!=</span>a2.age)
            <span style="color:#66d9ef">return</span> a1.age<span style="color:#f92672">&gt;</span>a2.age;<span style="color:#75715e">//大的排前
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span>
            <span style="color:#66d9ef">return</span> strcmp(a1.name,a2.name)<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span>;<span style="color:#75715e">//a1字典序小则strcmp返回值小于0，
</span><span style="color:#75715e"></span>    }
};
</code></pre></div><p><strong>二分查找：</strong></p>
<p>binary_search , lower_bound , upper_bound//查找前需排序</p>
<p>这三个使用方式和sort基本一致：</p>
<p><code>binary_search(数组名+n1,数组名+n2,值)/binary_search(数组名+n1,数组名+n2,值,自定义规则名());</code></p>
<p><code>//这里的自定义规则名和进行查找前排序时采用的规则一致 </code></p>
<!-- raw HTML omitted -->
<p><strong>容器：</strong></p>
<p>(1)multiset和set</p>
<p><code>mulitiset&lt;T,Rule&gt; mst;//声明变量，规则定义方式见上，不定义规则默认从小到大</code><br>
<code>set&lt;T,Rule&gt; st;</code></p>
<p>区别：set中没有且不能有相同元素，insert时如果set容器里已有一个元素和要插入的值相同，那么插入失败。</p>
<h5 id="ps1关于insert的返回值">PS1.关于insert的返回值：</h5>
<p>返回值为 pair&lt;set&lt;T,Rule&gt;::iterator, bool&gt;类型的迭代器//这个说法有问题吗？<br>
示例</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>; 
pair<span style="color:#f92672">&lt;</span>set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator, <span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> i <span style="color:#f92672">=</span> st.insert(tmp);
<span style="color:#75715e">//tmp值为3，如果st中已有3，则返回false和set&lt;int&gt;::iterator迭代器（指向st中3的位置）；
</span><span style="color:#75715e">//如果没有，插入成功，返回true和set&lt;int&gt;::iterator迭代器（指向插入后所在的位置）
</span></code></pre></div><h5 id="ps2pair类型见下面map处">PS2.pair类型见下面map处</h5>
<pre><code>st.insert(tmp)//插入到合适位置，按规则
        st.find(tmp)//找到容器中第一个 值为tmp的元素，返回其位置
        st.erase(tmp)//删除容器中所有 值为tmp的元素，返回其位置
        st.begin()//返回容器第一个位置
        st.end()//返回容器中最后一个元素后面的位置
        迭代器set&lt;T,Rule&gt;::iterator p;//近似指针，有区别，只能做！=，== 比较，++，--操作
  multimap map
</code></pre><p>(2)multimap和map</p>
<p>multimap&lt;T,T&gt; mmp;<br>
map&lt;T,T&gt; mp;</p>
<p>元素类型是pair&lt;T,T&gt;，也可以自定义规则。</p>
<h5 id="pspairtt等同于">PS.pair&lt;T,T&gt;等同于</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">struct</span> {
    T first;
    T second;
};
</code></pre></div><p>1.map中第一个，即first可以看作关键字，默认按关键字从小到大排序。<br>
2.map类型的变量可以用 []  ，下标为关键字，返回值为second的值。</p>
<p><strong>注意：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> , <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> mp;
mp[Amy] <span style="color:#f92672">=</span> <span style="color:#ae81ff">78</span>;
<span style="color:#75715e">//若mp中有Amy，则将second的值设为78；
</span><span style="color:#75715e">//若没有Amy，则插入一个元素（first为Amy，second为0），然后把78赋值给second
</span></code></pre></div><p><strong>区别：</strong> 和multiset,set区别类似，map不能有重复元素，所以插入也可能失败.</p>
<h4 id="二oj题热血角斗场第十二周第四题冷血角斗场第十三周">二、OJ题：热血角斗场（第十二周第四题），冷血角斗场（第十三周）</h4>
<p><strong>区别：</strong></p>
<p>十二周——实力差值相同找实力值小的；保证实力值都不同<br>
十三周——实力差值相同找ID小的；实力值可以相同</p>
<p><strong>十三周思路</strong></p>
<p>用multimap的话在碰到插入位置左边的值有相同值时要找id最小的，比较麻烦；插入的值在容器中有相同的时候找最小id也很麻烦。</p>
<p>所以采用map，实力值为first，每次插入，若插入的值在容器中有相同值，那么会插入失败，返回一个迭代器，这时比较second的值，修改为较小的。由于输出要求是按时间顺序，所以直接输出插入元素的id和容器中相同值对应的id；</p>
<p>若插入的值没有相同值，插入成功，然后比较左右元素的实力差值大小，输出插入id和差值小的id，差值相同输出左边的。</p>
<p><strong>十二周思路</strong></p>
<p>用set即可，题目说明保证实力值均不同，不需要考虑插入失败的情况，每次输入值后就插入到set容器中，利用insert的返回值中的迭代器来比较左右元素，按要求输出即可。</p>
<h5 id="错误点">错误点：</h5>
<p>1.输入输出用scanf和printf，cin、cout可能超时；<br>
2.使用迭代器的时候没注意边界，指向第一个元素位置执行 &ndash; 或指向最后一个元素位置执行 ++ 之后，参与到正常的逻辑运算中可能会出错。</p>
<h5 id="ps十二周的题我没判断边界结果在cb上运行结果正确在oj上wrong-answer蒙蔽了好久做了十三周的题用了map的时候cb运行结果反映出了边界的问题才明白错误的地方">PS.十二周的题我没判断边界，结果在cb上运行结果正确，在OJ上Wrong Answer，蒙蔽了好久，做了十三周的题，用了map的时候，cb运行结果反映出了边界的问题才明白错误的地方。</h5>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
