<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on twangreal的博客</title>
    <link>https://twangreal.github.io/post/</link>
    <description>Recent content in Posts on twangreal的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 28 Mar 2020 14:11:44 +0800</lastBuildDate>
    
	<atom:link href="https://twangreal.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>week6_继承中的重载、覆盖、虚函数</title>
      <link>https://twangreal.github.io/post/week6_%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E9%87%8D%E8%BD%BD%E8%A6%86%E7%9B%96%E8%99%9A%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 28 Mar 2020 14:11:44 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/week6_%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E9%87%8D%E8%BD%BD%E8%A6%86%E7%9B%96%E8%99%9A%E5%87%BD%E6%95%B0/</guid>
      <description>一、重载和覆盖（派生类中覆盖基类中重载的函数） “派生类可以覆盖重载函数的0个或多个实例。”
“如果派生类希望所有的重载版本对于它来说都是可见的，那么它需要覆盖所有的版本，或者一个也不覆盖。”
PS.using 15.5节 P546//待补充
二、虚函数和覆盖 虚函数覆盖后还是虚函数。
“当我们在派生类中覆盖了某个虚函数时，可以再一次使用virtual关键字指出该函数的性质。然而这么做并非必须，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。” PS.这个它指 同名同参数表的函数。
“一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。”
示例：
#include&amp;lt;iostream&amp;gt;using namespace std; class Base { public: virtual void print(int a) { cout &amp;lt;&amp;lt; &amp;#34;Base print int &amp;#34; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl; } void print(char a,char b) { cout &amp;lt;&amp;lt; &amp;#34;Base print char &amp;#34; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl; } virtual void print(double a) { cout &amp;lt;&amp;lt; &amp;#34;Base print double &amp;#34; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl; } }; class Derived :public Base { public: void print(int a)//覆盖了基类中的虚函数， 	{ cout &amp;lt;&amp;lt; &amp;#34;Derived print int &amp;#34; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl; } void print(double a)//覆盖了基类中的虚函数， 	{ Base::print(&amp;#39;d&amp;#39;,&amp;#39;d&amp;#39;);//不加Base::就会报错，因为基类Base中的void print(char a,char b)不可见 	cout &amp;lt;&amp;lt; &amp;#34;Derived print double &amp;#34; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl; } }; int main() { Derived d; Base *bp = &amp;amp;d; bp-&amp;gt;print(5.</description>
    </item>
    
    <item>
      <title>Week7_流操纵算子</title>
      <link>https://twangreal.github.io/post/week7_%E6%B5%81%E6%93%8D%E7%BA%B5%E7%AE%97%E5%AD%90/</link>
      <pubDate>Fri, 27 Mar 2020 16:29:17 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/week7_%E6%B5%81%E6%93%8D%E7%BA%B5%E7%AE%97%E5%AD%90/</guid>
      <description>一、整数流的基数： 流操纵算子dec ， oct ， hex ，setbase。
dec十进制，oct八进制，hex十六进制，setbase自定义任意进制
#include&amp;lt;iostream&amp;gt;#include&amp;lt;iomanip&amp;gt;//整数流的基数：流操纵算子dec,oct,hex int n = 10; cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; hex &amp;lt;&amp;lt; n &amp;lt;&amp;lt; “\n”//流操作算子是长效的， 	&amp;lt;&amp;lt; dec &amp;lt;&amp;lt; n &amp;lt;&amp;lt; “\n”//即“一旦设置后就一直起作用，直到用另一个流操作算子来替代”。 	&amp;lt;&amp;lt; oct &amp;lt;&amp;lt; n &amp;lt;&amp;lt; endl; //输出结果： //10 //a //10 //12 注意： 使用流操纵算子需要 #include 。
二、浮点数的精度 precision是成员函数，
​	cout.precision(5);
setprecision是流操纵算子
​	cout &amp;laquo; setprecision(5); // 可以连续输出
它们的功能相同。
指定输出浮点数的有效位数（非定点方式输出时）
指定输出浮点数的小数点后的位数（定点方式输出时）
定点方式：小数点必须出现在个位数后面
setiosflags(ios::fixed)//设置ios标记
resetiosflags(ios::fixed)//取消
#include &amp;lt;iostream&amp;gt;#include &amp;lt;iomanip&amp;gt;using namespace std; int main() { double x = 1234567.</description>
    </item>
    
    <item>
      <title>Week6_纯虚函数和抽象类</title>
      <link>https://twangreal.github.io/post/week6_%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/</link>
      <pubDate>Thu, 26 Mar 2020 10:33:40 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/week6_%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/</guid>
      <description>纯虚函数：没有函数体的虚函数 class A { private: int a; public: virtual void Print( ) = 0 ; //纯虚函数 	void fun() { cout &amp;lt;&amp;lt; &amp;#34;fun&amp;#34;; } }; 抽象类 （一）包含纯虚函数的类叫抽象类：
​	1.抽象类只能作为基类来派生新类使用，不能创建独立的抽象类的对象
​	2.可以定义抽象类的指针和引用，抽象类的指针和引用可以指向 由抽象类派生出来的类的对象
A a ; // 错，A 是抽象类，不能创建对象 （一）1 A * pa ; // ok,可以定义抽象类的指针和引用 （一）2 pa = new A ; //错误, A 是抽象类，不能创建对象 （一）1 （二）在抽象类的成员函数内可以调用纯虚函数，但是在构造函数或析构函数内部不能调用纯虚函数。
（三）如果一个类从抽象类派生而来，那么当且仅当它实现了基类中的所有纯虚函数，它才能成为非抽象类。
示例：
class A { public: virtual void f() = 0; //纯虚函数 	void g( ) { this-&amp;gt;f( ) ; //ok，（二）原因：抽象类不能创建独立的对象，所以g（）函数必然是A的派生类 	}	//调用的，即this指向的是A的派生类，而f（）是多态，所以执行B::f()函数 	A( ){ //f( ); // 错误，（二）原因：构造函数调用虚函数不是多态，那么调用的f（）就是A类中的f（）， 	}	//纯虚函数，而纯虚函数没有函数体，所以编译时就会出错 }; class B:public A{ public: void f(){ cout&amp;lt;&amp;lt;&amp;#34;B:f()&amp;#34;&amp;lt;&amp;lt;endl; //（三）实现了基类A中的所有纯虚函数  } }; int main(){ B b; b.</description>
    </item>
    
    <item>
      <title>Week6_虚析构函数</title>
      <link>https://twangreal.github.io/post/week6_%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 26 Mar 2020 10:22:53 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/week6_%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</guid>
      <description>虚析构函数 通过基类的指针删除派生类对象时，通常情况下只调用基类的析构函数
但是，删除一个派生类的对象时，应该先调用派生类的析构函数，然后调用基类的析构函数。
解决办法：把基类的析构函数声明为virtual
1.派生类的析构函数可以virtual不进行声明
2.通过基类的指针删除派生类对象时，首先调用派生类的析构函数，然后调用基类的析构函数
*3.一般来说，一个类如果定义了虚函数，则应该将析构函数也定义成虚函数。或者，一个类打算作为基类使用，也应该将析构函数定义成虚函数。
注意：不允许以虚函数作为构造函数
示例：
class son{ public: virtual ~son() {cout&amp;lt;&amp;lt;&amp;#34;bye from son&amp;#34;&amp;lt;&amp;lt;endl;};//如果不加virtual， }; //那么就不会引起执行son::~son(), class grandson:public son{ //只会输出bye from son public: ~grandson(){cout&amp;lt;&amp;lt;&amp;#34;bye from grandson&amp;#34;&amp;lt;&amp;lt;endl;}; }; int main() { son *pson; pson= new grandson();//基类指针指向派生类对象 	delete pson; return 0; } //输出： bye from grandson //bye from son //执行grandson::~grandson()，引起执行son::~son()！！！ </description>
    </item>
    
    <item>
      <title>Week6_多态的注意事项</title>
      <link>https://twangreal.github.io/post/week6_%E5%A4%9A%E6%80%81%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link>
      <pubDate>Wed, 25 Mar 2020 18:18:49 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/week6_%E5%A4%9A%E6%80%81%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid>
      <description>一、在成员函数中调用虚函数 在成员函数（静态成员函数、构造函数、析构函数除外）中调用其他虚成员函数的 语句 是多态的。
假设虚函数func2()，调用语句 func2(); 等价于 this-&amp;gt;func2() ，这个this指针是基类指针，基类指针调用虚函数，实现多态。
同理，静态成员函数没有具体对应的对象，不能使用this指针，所以调用虚函数不会实现多态。
二、在构造函数和析构函数中调用虚函数 在构造函数和析构函数中调用虚函数不是多态，因为 编译时即可确定调用的是那个函数 。
如果本类有该函数，调用的就是本类的函数；
如果本类没有，调用的就是直接基类的函数；
如果直接基类没有，调用的就是间接基类的函数，以此类推。
三、注意区分多态和非多态的情况 通过基类指针 或 引用 调用成员函数的语句，只有当该成员函数是虚函数时才会时多态。
PS.静态联编，编译时就能确定调用的是哪个类的成员函数。
只要基类中的某个函数被声明为虚函数，则派生类中的同名、同参数表的成员函数即使前面不写virtual关键字，也自动成为虚函数。</description>
    </item>
    
    <item>
      <title>Week6_多态的实现原理</title>
      <link>https://twangreal.github.io/post/week6_%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
      <pubDate>Wed, 25 Mar 2020 15:57:17 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/week6_%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
      <description>实现原理 思考 “多态”的关键 在于通过基类指针或引用调用一个虚函数时，编译时不确定到底调用的是基类还是派生类的函数，运行时才确定 &amp;mdash;- 这叫 “动态联编” 。
“动态联编” 底是怎么实现的呢？
多态实现的关键 &amp;mdash;&amp;mdash; 虚函数表 1.“每一个有虚函数的类（或有虚函数的类的派生类）都有一个虚函数表，该类的任何对象中都放着虚函数表的指针。”
2.虚函数表中列出了该类的虚函数地址。
注意：有虚函数的类的每个对象的大小都会多4个字节，多出来的4个字节就是用来放虚函数表的地址的。 （4个字节即指针的大小，64位为8字节）
示意图：
多态的函数调用语句被编译成 一系列根据基类指针所指向的（或基类引用所引用的）对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的指令。
验证对象开头存放虚函数表地址： #include &amp;lt;iostream&amp;gt;using namespace std; class A { public: virtual void Func() { cout &amp;lt;&amp;lt; &amp;#34;A::Func&amp;#34; &amp;lt;&amp;lt; endl; } }; class B:public A { public: virtual void Func() { cout &amp;lt;&amp;lt; &amp;#34;B::Func&amp;#34; &amp;lt;&amp;lt; endl; } }; int main() { A a; A * pa = new B(); pa-&amp;gt;Func();//输出B::Func 	//64位程序指针为8字节，这里假设运行再64位计算机上，如果是32位，long long改为int 	long long * p1 = (long long * ) &amp;amp; a;//long long正好8字节，所以*p1，*p2正好包含对象的 	long long * p2 = (long long * ) pa;//前8个字节，即虚函数表地址 	* p2 = * p1;//把pa指向的B类对象的开头虚函数表的地址改为了A类的虚函数表地址 	pa-&amp;gt;Func();//输出A::Func 	return 0; } //B::Func //A::Func 按照之前的原理 pa-&amp;gt;Func()语句编译后，将会去寻找pa指向的对象中存放的虚函数表的地址，然后到该地址找名为Func的虚函数，由于地址被语句“* p2 = * p1;”改为了A类的虚函数表地址，所以最后是在A类的虚函数表中找的Func，那么输出的自然就是A::Func 。</description>
    </item>
    
    <item>
      <title>Week6_多态</title>
      <link>https://twangreal.github.io/post/week6_%E5%A4%9A%E6%80%81/</link>
      <pubDate>Tue, 24 Mar 2020 17:11:36 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/week6_%E5%A4%9A%E6%80%81/</guid>
      <description>虚函数：类中声明时前面加了virtual关键字的成员函数。 class base { virtual int get() ; }; int base::get(){ } 注意：virtual 关键字只用在类定义里的函数声明中，写函数体时不用。
多态类：包含虚函数的类称为多态类。 注意：静态成员函数不能是虚函数，构造函数不能是虚函数。
注意：虚函数可以参与多态，普通函数不行。
表现形式：基类指针和基类引用。（即通过基类的指针或基类的引用调用虚函数的语句是多态的） 一、派生类的指针可以赋给基类指针。
通过基类指针调用基类和派生类中的同名虚函数时:
（1）若该指针指向一个基类的对象，那么被调用是基类的虚函数；
（2）若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。这种机制就叫做“多态”。
class CBase { public: virtual void SomeVirtualFunction() { } }; class CDerived:public CBase { public : virtual void SomeVirtualFunction() { } }; int main() { CDerived ODerived; CBase * p = &amp;amp; ODerived; p -&amp;gt; SomeVirtualFunction(); //调用哪个虚函数取决于p指向哪种类型的对象 	return 0; } 二、派生类的对象可以赋给基类引用
通过基类引用调用基类和派生类中的同名虚函数时:
（1）若该引用引用的是一个基类的对象，那么被调用是基类的虚函数；
（2）若该引用引用的是一个派生类的对象，那么被调用的是派生类的虚函数。这种机制也叫做“多态”。
class CBase { public: virtual void SomeVirtualFunction() { } }; class CDerived:public CBase { public : virtual void SomeVirtualFunction() { } }; int main() { CDerived ODerived; CBase &amp;amp; r = ODerived; r.</description>
    </item>
    
    <item>
      <title>Week5_魔兽世界2装备</title>
      <link>https://twangreal.github.io/post/week5_%E9%AD%94%E5%85%BD%E4%B8%96%E7%95%8C2%E8%A3%85%E5%A4%87/</link>
      <pubDate>Sun, 22 Mar 2020 16:33:31 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/week5_%E9%AD%94%E5%85%BD%E4%B8%96%E7%95%8C2%E8%A3%85%E5%A4%87/</guid>
      <description>类之间关系分析 司令部类Headquarter，武士类Warrior，Dragon、Ninja、Iceman、Lion、Wolf，武器类Weapon
Headquarter和Warrior类似“狗和主人”的复合关系，不是对方的一部分，但是又属于和拥有的关系。
Warrior和Dragon……是继承关系。
Weapon，Dragon有一把武器，即拥有一个Weapon类的成员，Dragon是一个封闭派生类。
代码： #include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;using namespace std; enum{DRAGON,NINJA,ICEMAN,LION,WOLF}; const int WarriorKindNum = 5; const int WeaponKindNum = 3; const int MaxWarriorNum = 1000; class Warrior; class Weapon{ public: int wpKindNo; static const char * wpName[WeaponKindNum]; }; class Headquater{ private: int hTotalLifeValue; int hTotalWarriorNum;//&amp;lt;MaxWarriorNum  bool isStop; int Color;//0red,1blue  Warrior *pWarrior[MaxWarriorNum]; static int hMakingWarriorSeq[2][WarriorKindNum]; int hCurMakingWarSeqIndex; public: int eachKindWarriorNum[WarriorKindNum]; void init(int color,int lifeValue); int produce(int hTime); int getTotalLV(){return hTotalLifeValue;} int getColor(){return Color;} ~Headquater(){ for(int i=0;i&amp;lt;hTotalWarriorNum;++i) delete pWarrior[i]; } }; class Warrior{ private: static const char * warNames[WarriorKindNum]; protected: Headquater *pHeadquater;//指向所属司令部  int warNo;//第几个降生 public: static int InitLifeValue[WarriorKindNum]; Warrior(Headquater *ph,int totalWarNum):pHeadquater(ph),warNo(totalWarNum){} virtual void PrintResult(int htime)=0; void PrintResult(int htime,int kindNo); virtual ~Warrior(){} }; class Dragon:public Warrior{ private: Weapon wp; double morale; public: Dragon(Headquater *ph,int totalWarNum):Warrior(ph,totalWarNum){ wp.</description>
    </item>
    
    <item>
      <title>Week5_思考题</title>
      <link>https://twangreal.github.io/post/week5_%E6%80%9D%E8%80%83%E9%A2%98/</link>
      <pubDate>Thu, 19 Mar 2020 13:18:02 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/week5_%E6%80%9D%E8%80%83%E9%A2%98/</guid>
      <description>一、如何实现string类，可以使得sizeof(string) = 4？这样实现的string类如何才能在常数时间内求得string对象中字符串的长度？ 答：考虑到一般情况指针都是4个字节大小，所有让string类中包含一个char *指针，指向字符串，来实现。
要在常数时间内求得长度，显然strlen不行，那么就在字符串开头增加4个字节（int的大小）来存储字符串长度。
二、派生类对象生成时要先执行基类构造函数，消亡时要先执行自身析构函数，在执行基类析构函数，为什么？ 答：派生类对象生成和消亡时分别执行构造函数和析构函数，而这两个函数执行时有可能会用到从基类继承过来的成员变量，所以要先基类构造，后基类析构。
PS.关于对象占用的空间大小 按理说，对象占用空间大小等于各成员变量占用的存储空间大小之和。
class CStudent{ private: string name; string id; char gender; int age; public: ....... }//string 4，int 4， char 1，合计13 //但是sizeof（CStudent）返回16，？？ 原因：计算机内部CPU和内存之间传送数据都是以4字节（32位，64位8字节）为单位进行的，处于传输效率的考虑，应该尽量使对象的成员变量的地址是4或8的整数倍，这叫做对齐。编译器位CStudent对象中的char gender补齐3个字节，使得age能够对齐，因此CStudent变成了16字节。
三、访问控制和继承（公有、私有、保护继承） class A{ public: int pub_num; private: int pri_num; protected: int prot_num; //A类中记作区域（1） }; class B:private A{//类派生列表，（private 派生访问说明符）  int f(){return pub_num;} //int g(){return pri_num;}//error,private成员变量不能访问  int h(){return prot_num;} //B类，A类的直接派生类，记作区域（2） }; //其他地方，例如main中、B的派生类中，记作区域（3） int main() { B b; //	b.pub_num=1; //	b.</description>
    </item>
    
    <item>
      <title>Week5_其他</title>
      <link>https://twangreal.github.io/post/week5_%E5%85%B6%E4%BB%96/</link>
      <pubDate>Wed, 18 Mar 2020 16:05:22 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/week5_%E5%85%B6%E4%BB%96/</guid>
      <description>一、基类和派生类指针的互相转换 （1）公有派生的情况下,派生类对象的指针可以直接赋值给基类指针
（2）基类的指针不能赋值给派生类的指针，除非强制类型转换，
Base * ptrBase = &amp;amp;objDerived;//本来就指向一个派生类的对象 Derived *ptrDerived = (Derived * ) ptrBase; 注意 ：需要保证被转换的基类指针本来就指向一个派生类的对象。
注意2 ：即便基类指针指向的是一个派生类对象，也不能通过基类指针访问基类没有而派生类中有的成员。
二、派生类和赋值运算符 如果基类重载了赋值运算符= 而派生类没有，
那么在派生类对象之间赋值，或用派生类对象对基类对象进行赋值时，
其中基类部分的赋值操作时调用被基类重载的“=”完成的。</description>
    </item>
    
    <item>
      <title>Week5_公有继承的赋值兼容规则</title>
      <link>https://twangreal.github.io/post/week5_%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF%E7%9A%84%E8%B5%8B%E5%80%BC%E5%85%BC%E5%AE%B9%E8%A7%84%E5%88%99/</link>
      <pubDate>Wed, 18 Mar 2020 15:24:10 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/week5_%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF%E7%9A%84%E8%B5%8B%E5%80%BC%E5%85%BC%E5%AE%B9%E8%A7%84%E5%88%99/</guid>
      <description>一、public继承 class base { }; class derived : public base { };//public-&amp;gt;公有派生，还可以写private、protected，但不常用 base b; derived d; public继承的赋值兼容规则：
1） 派生类的对象可以赋值给基类对象
b = d;//派生类对象d中包含的基类对象赋值给b2） 派生类对象可以初始化基类引用
base &amp;amp; br = d;//br引用了派生类对象d中包含的基类对象3） 派生类对象的地址可以赋值给基类指针
base * pb = &amp;amp; d;//基类指针指向了派生类对象d中包含的基类对象注意：如果派生方式是 private或protected，则上述三条不可行，下面的这条结论也不成立。
在公有派生的情况下，可以说，派生类对象也是基类对象，任何本该出现基类对象的地方，如果出现的是派生类对象，也是没有问题的。
二、protected继承和private继承 class base { }; class derived : protected base { }; base b; derived d; /*protected继承时，基类的public成员和protected成员成为派生类的protected成员。 • private继承时，基类的public成员和protected成员成为派生类的private成员。 • protected和private继承不是“是”的关系。 三、直接基类和间接基类（多层次的派生） (1)类A派生类B，类B派生类C，类C派生类D，……A &amp;ndash;&amp;gt; B &amp;ndash;&amp;gt; C &amp;ndash;&amp;gt; D
– 类A是类B的直接基类
– 类B是类C的直接基类，类A是类C的间接基类</description>
    </item>
    
    <item>
      <title>Week5_派生类的构造函数</title>
      <link>https://twangreal.github.io/post/week5_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 18 Mar 2020 14:52:10 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/week5_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</guid>
      <description>一、构造函数 class Bug { private : int nLegs; int nColor; public: int nType; Bug ( int legs, int color); void PrintBug (){ }; }; class FlyBug: public Bug // FlyBug是Bug的派生类 { int nWings; public: FlyBug( int legs,int color, int wings); }; Bug::Bug( int legs, int color) { nLegs = legs; nColor = color; } //错误的FlyBug构造函数 FlyBug::FlyBug ( int legs,int color, int wings) { nLegs = legs; // 不能访问**nLegs是私有成员** 	nColor = color; // 不能访问**nColor是私有成员** 	nType = 1; // ok**nType是公有成员** 	nWings = wings; } //正确的FlyBug构造函数： FlyBug::FlyBug ( int legs, int color, int wings):Bug( legs, color)//初始化列表中， {	//调用基类的构造函数 nWings = wings; } int main() { FlyBug fb ( 2,3,4); fb.</description>
    </item>
    
    <item>
      <title>Week5_覆盖和保护成员</title>
      <link>https://twangreal.github.io/post/week5_%E8%A6%86%E7%9B%96%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%88%90%E5%91%98/</link>
      <pubDate>Wed, 18 Mar 2020 14:30:02 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/week5_%E8%A6%86%E7%9B%96%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%88%90%E5%91%98/</guid>
      <description>一、覆盖 派生类可以定义一个和基类成员同名的成员，这叫覆盖。
在派生类中访问这类成员时，缺省的情况是访问派生类中定义的成员。要在派生类中访问由基类定义的同名成员时，要使用作用域符号:: 。
基类和派生类有同名成员的情况：
//**一般来说，基类和派生类不定义同名成员变量。**定义同名成员函数是常见的。 class base { int j; public: int i; void func(); }; class derived :public base{ public: int i; void access(); void func(); }; void derived::access() { j = 5; //error,private 	i = 5; //引用的是派生类的 i 	base::i = 5; //引用的是基类的 i 	func(); //派生类的 	base::func(); //基类的 } derived obj; obj.i = 1; obj.base::i = 1; //obj占用的存储空间: //Base::j //Base::i //i 二、类的保护成员 另一种存取权限说明符：protected
• 基类的private成员：可以被下列函数访问</description>
    </item>
    
    <item>
      <title>Week5_继承和复合关系</title>
      <link>https://twangreal.github.io/post/week5_%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%8D%E5%90%88%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Tue, 17 Mar 2020 17:40:07 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/week5_%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%8D%E5%90%88%E5%85%B3%E7%B3%BB/</guid>
      <description>一、类之间的两种关系 继承：“是” 关系。
– 基类 A，B是基类A的派生类。
– 逻辑上要求：“一个B对象也是一个A对象”。
复合：“有” 关系。
– 类C中“有”成员变量k，k是类D的对象，则C和D是复合关系。
– 一般逻辑上要求：“D对象是C对象的固有属性或组成部分”。
PS.则C为封闭类
二、继承关系的使用 写了一个 CMan 类代表男人
后来又发现需要一个CWoman类来代表女人
CWoman类和CMan类有共同之处，就让CWoman类从CMan类派生而来，是否合适？
是不合理的!
因为“一个女人也是一个男人”从逻辑上不成立!
好的做法是概括男人和女人共同特点，
写一个 CHuman类，代表“人”, 然后CMan和CWoman都从CHuman派生。
三、复合关系的使用 （1）几何形体程序中，需要写“点”类，也需要写“圆”类，两者的关系就是复合关系 &amp;mdash;- 每一个“圆”对象里都包含(有)一个“点”对象，这个“点”对象就是圆心。
class CPoint { double x,y; friend class CCircle; //便于Ccirle类操作其圆心 }; class CCircle { double r; CPoint center; }; （2）如果要写一个小区养狗管理程序，需要写一个“业主”类，还需要写一个“狗”类。 而狗是有 “主人” 的，主人当然是业主(假定狗只有一个主人，但一个业主可以有最多10条狗）
//！错误，循环定义！ class CDog; class CMaster { CDog dogs[10]; }; class CDog { CMaster m; }; 注意：避免循环定义的方法是 在一个类中使用另一个类的指针，而不是对象作为成员变量。</description>
    </item>
    
    <item>
      <title>week5_继承与派生</title>
      <link>https://twangreal.github.io/post/week5_%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/</link>
      <pubDate>Tue, 17 Mar 2020 16:03:51 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/week5_%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/</guid>
      <description>继承与派生 一、基本概念 1.继承：在定义一个新的类B时，如果该类与某个已有的类A相似(指的是B拥有A的全部特点)，那么就可以把A作为一个基类，而把B作为基类的一个派生类(也称子类)。
​	a.派生类是通过对基类进行修改和扩充得到的。在派生类中，可以扩充新的成员变量和成员函数。
​	b.派生类一经定义后，可以独立使用，不依赖于基类。
2.派生类拥有基类的全部成员函数和成员变量，不论是private、protected、public 。
​	在派生类的各个成员函数中，不能访问基类中的private成员。
//派生类的写法class 派生类名：public 基类名{};//示例class CStudent {private:string sName;int nAge;public:bool IsThreeGood() { };void SetName( const string &amp;amp; name ) { sName = name; }//......}; class CUndergraduateStudent: public CStudent {private: int nDepartment;public:bool IsThreeGood() { ...... }; //覆盖，相同函数名	bool CanBaoYan() { .... };}; // 派生类的写法是：类名: public 基类名class CGraduatedStudent:public CStudent {private:int nDepartment;char szMentorName[20];public:int CountSalary() { .</description>
    </item>
    
    <item>
      <title>Week4思考题</title>
      <link>https://twangreal.github.io/post/week4sikaoti/</link>
      <pubDate>Mon, 16 Mar 2020 21:25:51 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/week4sikaoti/</guid>
      <description>第四周 运算符重载 &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; MOOC程序设计与算法（三） 4-2 为什么复制构造函数中不需要下面几条语句？ if(str==s.str)return;if(str)delete [] str;答：复制构造函数作用于初始化刚生成的对象，其中的指针str还没有指向任何空间。
4-3 长度可变的整型数组类 每次在数组尾部添加一个元素都要重新分配内存并且复制原有内容，效率低下，有什么办法能够加快添加元素的速度？ 答：预先多分配一些存储空间，例如在用于初始化对象的构造函数中，分配size+32的空间大小，那么在后续插入的32个元素都不用重新分配空间。
PS.可以参考vector容器的实现 vector//待续。。。。。。</description>
    </item>
    
    <item>
      <title>Week4作业题错误点</title>
      <link>https://twangreal.github.io/post/week4zouye/</link>
      <pubDate>Mon, 16 Mar 2020 17:19:51 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/week4zouye/</guid>
      <description>第四周 Week4运算符重载 MOOC程序设计与算法（三） 001：MyString 1.动态内存分配，字符串，新建内存空间的时候，大小size要+1（&#39;\0&amp;rsquo;），用memcpy拷贝要把&amp;rsquo;\0&#39;拷进去，或者用strcpy
2.浅拷贝和深拷贝
​	a.复制构造函数
​	b.赋值运算符=（需要重载）
​	c.自定义复制函数（比如Copy()）
​	d.动态分配一片新的内存空间，复制
PS.(问题)memcpy和strcpy比较 strcpy和memcpy主要有以下3方面的区别：
(1)复制的内容不同。
strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。
(2)复制的方法不同。
strcpy不需要指定长度，只用于字符串复制，不仅复制字符串内容，还复制字符串的结束符(&#39;\0&amp;rsquo;)。它遇到结束 符&amp;rdquo;\0&amp;quot;结束，容易溢出。memcpy则是根据其第3个参数决定复制的长度。
(3)用途不同。
通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy
原型和实现： strcpy函数原型是：char* strcpy(char* dest, const char* src);
char * strcpy(char * dest, const char * src) // 实现src到dest的复制{if ((src == NULL) || (dest == NULL)) //判断参数src和dest的有效性{return NULL;}char *strdest = dest; //保存目标字符串的首地址 while ((*strDest++ = *strSrc++)!=&amp;#39;\0&amp;#39;); //把src字符串的内容复制到dest下 return strdest;}memset实现：</description>
    </item>
    
    <item>
      <title>week3知识点总结</title>
      <link>https://twangreal.github.io/post/week3/</link>
      <pubDate>Fri, 13 Mar 2020 14:20:51 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/week3/</guid>
      <description>第三周 知识点 一、this指针 ​ 成员函数中用于指向当前对象的指针；静态成员函数中没有this指针。
二、静态成员变量 ​ 1.只有一份，所有同类对象共享；
​ 2.必须在定义类的文件中，对静态成员变量进行一次声明或初始化；//（重要）
​ 3.静态成员变量本质上是全局变量；
​ 4.静态成员函数本上是全局函数；
​ 5.静态成员函数中不能访问非静态成员变量，也不能调用非静态成员函数；
注意 ：关于静态成员变量的 初始化，不是静态成员变量是public还是private还是protected都是在类外初始化，没有影响；但是对于静态成员变量的访问、值的修改 和public还是private还是protected有关。
三、成员对象和封闭类 一个类的成员变量是另一个类的对象，则该类为封闭类。
1.初始化：构造函数，初始化列表（建议）
2.封闭类构造函数和析构函数执行顺序：构造先成员对象后封闭类，析构先封闭类后成员对象
3.封闭类用默认复制构造函数（非自定义）初始化对象时，成员对象也会自动调用其所属类的复制构造函数来初始化
四、常量对象、常量成员函数 常量对象const A a；//原则：不允许修改对象的成员变量
常量成员函数，原则：不允许修改当前对象
基于这样的原则，可以方便记忆这几条特点：
1.常量对象只能调用 构造函数，析构函数，常量成员函数
2.常量成员函数不能调用同类非常量成员函数，可以调用静态成员函数（因为静态成员函数不属于某个特定对象，所以不会修改常量对象，）
PS1. 常量成员函数定义 T 函数名() const {return ;//函数体}PS2.常量成员函数的重载 ​	相同的函数名，一个常量一个非常量，非常量对象调用非常量的，常量对象调用常量的。
PS3.常量型成员变量和引用型成员变量必须用构造函数的初始化列表方式初始化，且常量型成员变量的值一旦初始化后不能再改变P55 五、友元 声明友元可以让其他类或非成员函数调用私有变量。
1.全局函数，其他类的成员函数（非私有）
2.其他类
注意：友元关系不能传递，不能继承（也不相互，即A声明B为自己的友元，则B是A的友元，A不是B的友元）</description>
    </item>
    
    <item>
      <title>week3 NO.5</title>
      <link>https://twangreal.github.io/post/mssj_beizhan/</link>
      <pubDate>Thu, 12 Mar 2020 23:42:51 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/mssj_beizhan/</guid>
      <description>第三周 作业第5题 魔兽世界之一：备战 #include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;struct headquarter{public:int life;int number;};headquarter red;headquarter blue;struct dragon{public:static int strength;static int red_num;static int blue_num;dragon(char c){if(c==0){++dragon::red_num;++red.number;}else{++dragon::blue_num;++blue.number;}}};struct ninja{public:static int strength;static int red_num;static int blue_num;ninja(char c){if(c==0){++ninja::red_num;++red.number;}else{++ninja::blue_num;++blue.</description>
    </item>
    
    <item>
      <title>week3 NO.4</title>
      <link>https://twangreal.github.io/post/zhegezhizhen/</link>
      <pubDate>Thu, 12 Mar 2020 17:49:51 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/zhegezhizhen/</guid>
      <description>第三周 作业第4题 这个指针哪来的 #include &amp;lt;iostream&amp;gt;using namespace std;struct A{int v;A(int vv):v(vv) { }// 在此处补充你的代码 A * getPointer() const{return this;//this指向的是常量a，即返回的是const A类型的对象的地址，getPointer前为const A * }//补充代码};int main(){int i;int * j= &amp;amp;i;const int *k = j;const A a(10);//由于这个对象a为常量，所以下面它调用的getPointer就要求是常量成员函数	const A * p = a.getPointer();//指向常量的指针p，这就要求a.getPointer为 类A对象的地址/指向类A对象的指针q，而getPointer是常量成员函数	cout &amp;lt;&amp;lt; p-&amp;gt;v &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>第十二、十三周</title>
      <link>https://twangreal.github.io/post/%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%8D%81%E4%B8%89%E5%91%A8/</link>
      <pubDate>Wed, 11 Mar 2020 16:29:51 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%8D%81%E4%B8%89%E5%91%A8/</guid>
      <description>第十二、十三周学习总结 MOOC程序设计与算法（一） 一、知识点 1.STL(standard template library) sort排序 :
常用格式 sort(数组名+n1,数组名+n2);
作用：对一个数组排序，默认排序方式——从小到大
实例：int a[4]={5,6,8,9};sort(a,a+4);
从大到小：sort(数组名+n1,数组名+n2,greater&amp;lt;T&amp;gt;());//T为数组的类型
进阶——自定义规则排序：sort(数组名+n1,数组名+n2,自定义规则名());//T为数组的类型
自定义规则形式：
struct 规则名{bool operator() (const T &amp;amp;a1, const T &amp;amp;a2 ) const{return ;//这里定义排序规则	}};//示例1：从大到小排struct Rule{bool operator() (const int &amp;amp;a1, const int &amp;amp;a2 ) const{return a1&amp;gt;a2;//a1的值大于a2，返回true，表示a1能排在a2前；否则返回法拉瑟，表示a1不能排在a2前 }};//示例2：有两个成员变量的结构组成的数组排序，姓名、年龄，年龄大的排前面，年龄相同的姓名字典序小的排前面struct P{char name[10];int age;};//结构Pstruct Rule{bool operator() (const P &amp;amp;a1, const P &amp;amp;a2 ) const{if(a1.</description>
    </item>
    
    <item>
      <title>平衡二叉树</title>
      <link>https://twangreal.github.io/post/blogtest/</link>
      <pubDate>Fri, 11 Oct 2019 16:29:51 +0800</pubDate>
      
      <guid>https://twangreal.github.io/post/blogtest/</guid>
      <description>关于平衡二叉树是不是二叉排序树 答案是 是的。
平衡二叉树的定义 平衡二叉树或者是一棵空树，或者是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树的高度差的绝对值不超过1 。
从这个定义看，平衡二叉树应当是二叉树，不一定是二叉排序树，但是： “我们通常将平衡二叉树默认为二叉排序树，故平衡二叉树的概念包含两个方面：平衡、有序 ”。1
AVL树 AVL树：AVL(Adelson-Velskii 和 Landis)树是带有平衡条件的二叉查找树（即二叉排序树），一棵AVL树是其每个结点的左子树和右子树的高度最多差1的二叉查找树。2
其实我们通常说的 平衡二叉树 指的就是AVL树，所以是二叉排序树。
  引用自《2020年计算机专业基础综合考试真题思路分析》 &amp;#x21a9;&amp;#xfe0e;
 引用自《数据结构与算法分析——C语言描述》, Mark Allen Weiss. &amp;#x21a9;&amp;#xfe0e;
   </description>
    </item>
    
  </channel>
</rss>