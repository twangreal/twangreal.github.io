<!doctype html>
<html lang="en-us">
  <head>
    <title>Week6_多态 // twangreal的博客</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.67.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="twangreal" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://twangreal.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Week6_多态"/>
<meta name="twitter:description" content="虚函数：类中声明时前面加了virtual关键字的成员函数。 class base { virtual int get() ; }; int base::get(){ } 注意：virtual 关键字只用在类定义里的函数声明中，写函数体时不用。
多态类：包含虚函数的类称为多态类。 注意：静态成员函数不能是虚函数，构造函数不能是虚函数。
注意：虚函数可以参与多态，普通函数不行。
表现形式：基类指针和基类引用。（即通过基类的指针或基类的引用调用虚函数的语句是多态的） 一、派生类的指针可以赋给基类指针。
通过基类指针调用基类和派生类中的同名虚函数时:
（1）若该指针指向一个基类的对象，那么被调用是基类的虚函数；
（2）若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。这种机制就叫做“多态”。
class CBase { public: virtual void SomeVirtualFunction() { } }; class CDerived:public CBase { public : virtual void SomeVirtualFunction() { } }; int main() { CDerived ODerived; CBase * p = &amp; ODerived; p -&gt; SomeVirtualFunction(); //调用哪个虚函数取决于p指向哪种类型的对象 	return 0; } 二、派生类的对象可以赋给基类引用
通过基类引用调用基类和派生类中的同名虚函数时:
（1）若该引用引用的是一个基类的对象，那么被调用是基类的虚函数；
（2）若该引用引用的是一个派生类的对象，那么被调用的是派生类的虚函数。这种机制也叫做“多态”。
class CBase { public: virtual void SomeVirtualFunction() { } }; class CDerived:public CBase { public : virtual void SomeVirtualFunction() { } }; int main() { CDerived ODerived; CBase &amp; r = ODerived; r."/>

    <meta property="og:title" content="Week6_多态" />
<meta property="og:description" content="虚函数：类中声明时前面加了virtual关键字的成员函数。 class base { virtual int get() ; }; int base::get(){ } 注意：virtual 关键字只用在类定义里的函数声明中，写函数体时不用。
多态类：包含虚函数的类称为多态类。 注意：静态成员函数不能是虚函数，构造函数不能是虚函数。
注意：虚函数可以参与多态，普通函数不行。
表现形式：基类指针和基类引用。（即通过基类的指针或基类的引用调用虚函数的语句是多态的） 一、派生类的指针可以赋给基类指针。
通过基类指针调用基类和派生类中的同名虚函数时:
（1）若该指针指向一个基类的对象，那么被调用是基类的虚函数；
（2）若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。这种机制就叫做“多态”。
class CBase { public: virtual void SomeVirtualFunction() { } }; class CDerived:public CBase { public : virtual void SomeVirtualFunction() { } }; int main() { CDerived ODerived; CBase * p = &amp; ODerived; p -&gt; SomeVirtualFunction(); //调用哪个虚函数取决于p指向哪种类型的对象 	return 0; } 二、派生类的对象可以赋给基类引用
通过基类引用调用基类和派生类中的同名虚函数时:
（1）若该引用引用的是一个基类的对象，那么被调用是基类的虚函数；
（2）若该引用引用的是一个派生类的对象，那么被调用的是派生类的虚函数。这种机制也叫做“多态”。
class CBase { public: virtual void SomeVirtualFunction() { } }; class CDerived:public CBase { public : virtual void SomeVirtualFunction() { } }; int main() { CDerived ODerived; CBase &amp; r = ODerived; r." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://twangreal.github.io/post/week6_%E5%A4%9A%E6%80%81/" />
<meta property="article:published_time" content="2020-03-24T17:11:36+08:00" />
<meta property="article:modified_time" content="2020-03-24T17:11:36+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://twangreal.github.io/"><img class="app-header-avatar" src="/personal/cyberpunk1.jpg" alt="twangreal" /></a>
      <h1>twangreal的博客</h1>
      <p>面向对象程序设计基于三个基本概念：数据抽象、继承和动态绑定。  后台开发：编程语言、编译调试、网络通信、常用类库、HTTP协议、进程通信。</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/twangreal" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Week6_多态</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Mar 24, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          3 min read
        </div></div>
    </header>
    <div class="post-content">
      <h3 id="虚函数类中声明时前面加了virtual关键字的成员函数">虚函数：类中声明时前面加了virtual关键字的成员函数。</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">base</span> {
	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get</span>() ;
};
<span style="color:#66d9ef">int</span> base<span style="color:#f92672">::</span>get(){ }
</code></pre></div><p><strong>注意</strong>：virtual 关键字只用在类定义里的函数声明中，写函数体时不用。</p>
<h3 id="多态类包含虚函数的类称为多态类">多态类：包含虚函数的类称为多态类。</h3>
<p><strong>注意</strong>：静态成员函数不能是虚函数，构造函数不能是虚函数。</p>
<p><strong>注意</strong>：虚函数可以参与多态，普通函数不行。</p>
<h3 id="表现形式基类指针和基类引用即通过基类的指针或基类的引用调用虚函数的语句是多态的">表现形式：基类指针和基类引用。（即通过基类的指针或基类的引用调用虚函数的语句是多态的）</h3>
<p><strong>一、派生类的指针可以赋给基类指针。</strong></p>
<p>通过基类指针调用基类和派生类中的同名虚函数时:</p>
<p>（1）若该指针指向一个基类的对象，那么被调用是基类的虚函数；</p>
<p>（2）若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。这种机制就叫做“多态”。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CBase</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> SomeVirtualFunction() { }
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CDerived</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> CBase {
<span style="color:#66d9ef">public</span> <span style="color:#f92672">:</span>
	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> SomeVirtualFunction() { }
};
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
	CDerived ODerived;
	CBase <span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span> ODerived;
	p <span style="color:#f92672">-&gt;</span> SomeVirtualFunction(); <span style="color:#75715e">//调用哪个虚函数取决于p指向哪种类型的对象
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
} 
</code></pre></div><p><strong>二、派生类的对象可以赋给基类引用</strong></p>
<p>通过基类引用调用基类和派生类中的同名虚函数时:</p>
<p>（1）若该引用引用的是一个基类的对象，那么被调用是基类的虚函数；</p>
<p>（2）若该引用引用的是一个派生类的对象，那么被调用的是派生类的虚函数。这种机制也叫做“多态”。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CBase</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> SomeVirtualFunction() { }
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CDerived</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> CBase {
<span style="color:#66d9ef">public</span> <span style="color:#f92672">:</span>
	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> SomeVirtualFunction() { }
};
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
	CDerived ODerived;
	CBase <span style="color:#f92672">&amp;</span> r <span style="color:#f92672">=</span> ODerived;
	r.SomeVirtualFunction(); <span style="color:#75715e">//调用哪个虚函数取决于r引用哪种类型的对象
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
} 
</code></pre></div><h3 id="多态的作用">多态的作用：</h3>
<p>在面向对象的程序设计中使用多态，能够增强程序的可扩充性，即程序需要修改或增加功能的时候，需要改动和增加的代码较少。</p>
<h3 id="例子">例子：</h3>
<h4 id="几何形体处理程序">几何形体处理程序:</h4>
<p>输入若干个几何形体的参数，要求按面积排序输出。输出时要指明形状。
Input:
第一行是几何形体数目n（不超过100).下面有n行，每行以一个字母c开头.</p>
<p>若 c 是 ‘R’，则代表一个矩形，本行后面跟着两个整数，分别是矩形的宽和高；</p>
<p>若 c 是 ‘C’，则代表一个圆，本行后面跟着一个整数代表其半径</p>
<p>若 c 是 ‘T’，则代表一个三角形，本行后面跟着三个整数，代表三条边的长度</p>
<p>Output:</p>
<p>按面积从小到大依次输出每个几何形体的种类及面积。每行一个几何形体，输出格式为：</p>
<p>形体名称：面积</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">//Sample Input: 3
</span><span style="color:#75715e">//R 3 5
</span><span style="color:#75715e">//C 9
</span><span style="color:#75715e">//T 3 4 5
</span><span style="color:#75715e">//Sample Output
</span><span style="color:#75715e">//Triangle:6
</span><span style="color:#75715e">//Rectangle:15
</span><span style="color:#75715e">//Circle:254.34
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;math.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CShape</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">double</span> Area() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">//纯虚函数
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PrintInfo</span>() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CRectangle</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> CShape
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> w,h;
	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">Area</span>();
	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PrintInfo</span>();
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CCircle</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> CShape {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> r;
	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">Area</span>();
	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PrintInfo</span>();
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CTriangle</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> CShape {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> a,b,c;
	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">Area</span>();
	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PrintInfo</span>();
}; 
<span style="color:#66d9ef">double</span> CRectangle<span style="color:#f92672">::</span>Area() {
	<span style="color:#66d9ef">return</span> w <span style="color:#f92672">*</span> h;
}
<span style="color:#66d9ef">void</span> CRectangle<span style="color:#f92672">::</span>PrintInfo() {
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Rectangle:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> Area() <span style="color:#f92672">&lt;&lt;</span> endl;
}
<span style="color:#66d9ef">double</span> CCircle<span style="color:#f92672">::</span>Area() {
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">3.14</span> <span style="color:#f92672">*</span> r <span style="color:#f92672">*</span> r ;
}
<span style="color:#66d9ef">void</span> CCircle<span style="color:#f92672">::</span>PrintInfo() {
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Circle:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> Area() <span style="color:#f92672">&lt;&lt;</span> endl;
}
<span style="color:#66d9ef">double</span> CTriangle<span style="color:#f92672">::</span>Area() {
	<span style="color:#66d9ef">double</span> p <span style="color:#f92672">=</span> ( a <span style="color:#f92672">+</span> b <span style="color:#f92672">+</span> c) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2.0</span>;
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sqrt</span>(p <span style="color:#f92672">*</span> ( p <span style="color:#f92672">-</span> a)<span style="color:#f92672">*</span>(p<span style="color:#f92672">-</span> b)<span style="color:#f92672">*</span>(p <span style="color:#f92672">-</span> c));
}
<span style="color:#66d9ef">void</span> CTriangle<span style="color:#f92672">::</span>PrintInfo() {
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Triangle:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> Area() <span style="color:#f92672">&lt;&lt;</span> endl;
}
CShape <span style="color:#f92672">*</span> pShapes[<span style="color:#ae81ff">100</span>];
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">MyCompare</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> s1, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> s2);
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
	<span style="color:#66d9ef">int</span> i; 
    <span style="color:#66d9ef">int</span> n;
	CRectangle <span style="color:#f92672">*</span> pr; CCircle <span style="color:#f92672">*</span> pc; CTriangle <span style="color:#f92672">*</span> pt;
	cin <span style="color:#f92672">&gt;&gt;</span> n;
	<span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> n;i <span style="color:#f92672">++</span> ) {
		<span style="color:#66d9ef">char</span> c;
		cin <span style="color:#f92672">&gt;&gt;</span> c;
		<span style="color:#66d9ef">switch</span>(c) {
		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;R&#39;</span><span style="color:#f92672">:</span>
			pr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CRectangle();
			cin <span style="color:#f92672">&gt;&gt;</span> pr<span style="color:#f92672">-&gt;</span>w <span style="color:#f92672">&gt;&gt;</span> pr<span style="color:#f92672">-&gt;</span>h;
			pShapes[i] <span style="color:#f92672">=</span> pr;
			<span style="color:#66d9ef">break</span>; 
		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;C&#39;</span><span style="color:#f92672">:</span>
            pc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CCircle();
            cin <span style="color:#f92672">&gt;&gt;</span> pc<span style="color:#f92672">-&gt;</span>r;
            pShapes[i] <span style="color:#f92672">=</span> pc;
            <span style="color:#66d9ef">break</span>;
		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;T&#39;</span><span style="color:#f92672">:</span>
            pt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CTriangle();
            cin <span style="color:#f92672">&gt;&gt;</span> pt<span style="color:#f92672">-&gt;</span>a <span style="color:#f92672">&gt;&gt;</span> pt<span style="color:#f92672">-&gt;</span>b <span style="color:#f92672">&gt;&gt;</span> pt<span style="color:#f92672">-&gt;</span>c;
			pShapes[i] <span style="color:#f92672">=</span> pt;
			<span style="color:#66d9ef">break</span>;
		}
	}<span style="color:#75715e">//for
</span><span style="color:#75715e"></span>	qsort(pShapes,n,<span style="color:#66d9ef">sizeof</span>( CShape<span style="color:#f92672">*</span>),MyCompare);
	<span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span>n;i <span style="color:#f92672">++</span>)
		pShapes[i]<span style="color:#f92672">-&gt;</span>PrintInfo();
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}<span style="color:#75715e">//main
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">MyCompare</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> s1, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> s2)
{
    <span style="color:#66d9ef">double</span> a1,a2;
    CShape <span style="color:#f92672">*</span> <span style="color:#f92672">*</span> p1 ; <span style="color:#75715e">// s1,s2 是 void * ，不可写 “* s1”来取得s1指向的内容
</span><span style="color:#75715e"></span>    CShape <span style="color:#f92672">*</span> <span style="color:#f92672">*</span> p2;
    p1 <span style="color:#f92672">=</span> ( CShape <span style="color:#f92672">*</span> <span style="color:#f92672">*</span> ) s1; <span style="color:#75715e">//s1,s2指向pShapes数组中的元素，数组元素的类型是CShape *
</span><span style="color:#75715e"></span>    p2 <span style="color:#f92672">=</span> ( CShape <span style="color:#f92672">*</span> <span style="color:#f92672">*</span> ) s2; <span style="color:#75715e">// 故 p1,p2都是指向指针的指针，类型为 CShape **
</span><span style="color:#75715e"></span>    a1 <span style="color:#f92672">=</span> (<span style="color:#f92672">*</span>p1)<span style="color:#f92672">-&gt;</span>Area(); <span style="color:#75715e">// * p1 的类型是 Cshape * ,是基类指针，故此句为多态
</span><span style="color:#75715e"></span>    a2 <span style="color:#f92672">=</span> (<span style="color:#f92672">*</span>p2)<span style="color:#f92672">-&gt;</span>Area();
    <span style="color:#66d9ef">if</span>( a1 <span style="color:#f92672">&lt;</span> a2 )
    	<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ( a2 <span style="color:#f92672">&lt;</span> a1 )
   		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">else</span>
    	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#75715e">//如果添加新的几何形体，比如五边形，则只需要 从CShape派生 出CPentagon,以及在main中的switch语句中增加一个case，其余部分不变！
</span></code></pre></div><p><strong>注意</strong>：用基类指针数组存放指向各种派生类对象的指针，然后遍历该数组，就能对各个派生类对象做各种操作，是很常用的做法</p>
<h3 id="又一个例子">又一个例子</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
<span style="color:#66d9ef">void</span> fun1() { <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>fun2(); } <span style="color:#75715e">//this是基类指针，fun2是虚函数，所以是多态
</span><span style="color:#75715e"></span><span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fun2</span>() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Base::fun2()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> Base {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> fun2() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Derived:fun2()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
};
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
Derived d;
Base <span style="color:#f92672">*</span> pBase <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span> d;
pBase<span style="color:#f92672">-&gt;</span>fun1();
<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p><strong>注意</strong>：</p>
<p>1.在非构造函数，非析构函数的成员函数中调用虚函数，是多态!!!</p>
<p>2.在构造函数和析构函数中调用虚函数，不是多态。</p>
<p>3.编译时即可确定，调用的函数是自己的类或基类中定义的函数，不会等到运行时才决定调用自己的还是派生类的函数。</p>
<p>4.<em><strong>派生类中和基类中虚函数同名同参数表的函数，不加virtual也自动成为虚函数</strong></em> 。</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
