<!doctype html>
<html lang="en-us">
  <head>
    <title>Week4作业题错误点 // twangreal的博客</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.67.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="twangreal" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://twangreal.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Week4作业题错误点"/>
<meta name="twitter:description" content="第四周 Week4运算符重载 MOOC程序设计与算法（三） 001：MyString 1.动态内存分配，字符串，新建内存空间的时候，大小size要&#43;1（&#39;\0&rsquo;），用memcpy拷贝要把&rsquo;\0&#39;拷进去，或者用strcpy
2.浅拷贝和深拷贝
​	a.复制构造函数
​	b.赋值运算符=（需要重载）
​	c.自定义复制函数（比如Copy()）
​	d.动态分配一片新的内存空间，复制
PS.(问题)memcpy和strcpy比较 strcpy和memcpy主要有以下3方面的区别：
(1)复制的内容不同。
strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。
(2)复制的方法不同。
strcpy不需要指定长度，只用于字符串复制，不仅复制字符串内容，还复制字符串的结束符(&#39;\0&rsquo;)。它遇到结束 符&rdquo;\0&quot;结束，容易溢出。memcpy则是根据其第3个参数决定复制的长度。
(3)用途不同。
通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy
原型和实现： strcpy函数原型是：char* strcpy(char* dest, const char* src);
char * strcpy(char * dest, const char * src) // 实现src到dest的复制{if ((src == NULL) || (dest == NULL)) //判断参数src和dest的有效性{return NULL;}char *strdest = dest; //保存目标字符串的首地址 while ((*strDest&#43;&#43; = *strSrc&#43;&#43;)!=&#39;\0&#39;); //把src字符串的内容复制到dest下 return strdest;}memset实现："/>

    <meta property="og:title" content="Week4作业题错误点" />
<meta property="og:description" content="第四周 Week4运算符重载 MOOC程序设计与算法（三） 001：MyString 1.动态内存分配，字符串，新建内存空间的时候，大小size要&#43;1（&#39;\0&rsquo;），用memcpy拷贝要把&rsquo;\0&#39;拷进去，或者用strcpy
2.浅拷贝和深拷贝
​	a.复制构造函数
​	b.赋值运算符=（需要重载）
​	c.自定义复制函数（比如Copy()）
​	d.动态分配一片新的内存空间，复制
PS.(问题)memcpy和strcpy比较 strcpy和memcpy主要有以下3方面的区别：
(1)复制的内容不同。
strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。
(2)复制的方法不同。
strcpy不需要指定长度，只用于字符串复制，不仅复制字符串内容，还复制字符串的结束符(&#39;\0&rsquo;)。它遇到结束 符&rdquo;\0&quot;结束，容易溢出。memcpy则是根据其第3个参数决定复制的长度。
(3)用途不同。
通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy
原型和实现： strcpy函数原型是：char* strcpy(char* dest, const char* src);
char * strcpy(char * dest, const char * src) // 实现src到dest的复制{if ((src == NULL) || (dest == NULL)) //判断参数src和dest的有效性{return NULL;}char *strdest = dest; //保存目标字符串的首地址 while ((*strDest&#43;&#43; = *strSrc&#43;&#43;)!=&#39;\0&#39;); //把src字符串的内容复制到dest下 return strdest;}memset实现：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://twangreal.github.io/post/week4zouye/" />
<meta property="article:published_time" content="2020-03-16T17:19:51+08:00" />
<meta property="article:modified_time" content="2020-03-16T17:19:51+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://twangreal.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="twangreal" /></a>
      <h1>twangreal的博客</h1>
      <p>后台开发：编程语言、编译调试、网络通信、常用类库、HTTP协议、进程通信。</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/gohugoio" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Week4作业题错误点</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Mar 16, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          2 min read
        </div></div>
    </header>
    <div class="post-content">
      <h2 id="第四周-week4运算符重载">第四周 Week4运算符重载</h2>
<h3 id="mooc程序设计与算法三">MOOC程序设计与算法（三）</h3>
<h4 id="001mystring">001：MyString</h4>
<p>1.动态内存分配，字符串，新建内存空间的时候，大小size要+1（'\0&rsquo;），用memcpy拷贝要把&rsquo;\0'拷进去，或者用strcpy</p>
<p>2.浅拷贝和深拷贝</p>
<p>​	a.复制构造函数<br>
​	b.赋值运算符=（需要重载）<br>
​	c.自定义复制函数（比如Copy()）<br>
​	d.动态分配一片新的内存空间，复制</p>
<h4 id="ps问题memcpy和strcpy比较"><strong>PS.(问题)memcpy和strcpy比较</strong></h4>
<p>strcpy和memcpy主要有以下3方面的区别：</p>
<p>(1)复制的内容不同。</p>
<p>strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。</p>
<p>(2)复制的方法不同。</p>
<p>strcpy不需要指定长度，只用于字符串复制，不仅复制字符串内容，还复制字符串的结束符('\0&rsquo;)。它遇到结束  符&rdquo;\0&quot;结束，容易溢出。memcpy则是根据其第3个参数决定复制的长度。</p>
<p>(3)用途不同。</p>
<p>通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</p>
<h4 id="原型和实现">原型和实现：</h4>
<p>strcpy函数原型是：char* strcpy(char* dest, const char* src);</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">strcpy</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> dest, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> src) <span style="color:#75715e">// 实现src到dest的复制
</span><span style="color:#75715e"></span>{
<span style="color:#66d9ef">if</span> ((src <span style="color:#f92672">==</span> NULL) <span style="color:#f92672">||</span> (dest <span style="color:#f92672">==</span> NULL)) <span style="color:#75715e">//判断参数src和dest的有效性
</span><span style="color:#75715e"></span>{
    <span style="color:#66d9ef">return</span> NULL;
}
    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>strdest <span style="color:#f92672">=</span> dest;        <span style="color:#75715e">//保存目标字符串的首地址
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> ((<span style="color:#f92672">*</span>strDest<span style="color:#f92672">++</span> <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>strSrc<span style="color:#f92672">++</span>)<span style="color:#f92672">!=</span><span style="color:#e6db74">&#39;\0&#39;</span>); <span style="color:#75715e">//把src字符串的内容复制到dest下
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> strdest;
}
                
</code></pre></div><p>memset实现：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">memcpy</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>memTo, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>memFrom, size_t size)
{
	<span style="color:#66d9ef">if</span>((memTo <span style="color:#f92672">==</span> NULL) <span style="color:#f92672">||</span> (memFrom <span style="color:#f92672">==</span> NULL)) <span style="color:#75715e">//memTo和memFrom必须有效
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> NULL;
	<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>tempFrom <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)memFrom;             <span style="color:#75715e">//保存memFrom首地址
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>tempTo <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)memTo;                  <span style="color:#75715e">//保存memTo首地址     
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span>(size <span style="color:#f92672">--</span> <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)                <span style="color:#75715e">//循环size次，复制memFrom的值到memTo中
</span><span style="color:#75715e"></span>		<span style="color:#f92672">*</span>tempTo<span style="color:#f92672">++</span> <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>tempFrom<span style="color:#f92672">++</span> ; 
	<span style="color:#66d9ef">return</span> memTo;
}
</code></pre></div><h4 id="002看上去好坑的运算符重载">002：看上去好坑的运算符重载</h4>
<p>​    略</p>
<h4 id="003惊呆point竟然能这样输入输出">003：惊呆！Point竟然能这样输入输出</h4>
<p>友元函数（全局）不一定是<em>在类中声明为友元，在类外定义函数</em>，可以一起写在定义类中。</p>
<p>例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>{
    <span style="color:#66d9ef">int</span> price;
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">int</span> exp(A <span style="color:#f92672">&amp;</span> a, <span style="color:#66d9ef">int</span> n){
        <span style="color:#66d9ef">return</span> a.price<span style="color:#f92672">+</span>n;
    }
}
</code></pre></div><h4 id="004第四周程序填空题3">004：第四周程序填空题3</h4>
<p><strong>1.(问题)类中成员变量在内存中地址</strong><br>
按照声明的先后相邻依次连续分布，不区分私有公有；成员函数不连续，且不紧邻成员变量。</p>
<p><strong>2.(注意)指向指针的指针</strong><br>
常用二级指针，但多级指针原理类似。</p>
<p>二级指针在动态分配内存空间时：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> <span style="color:#f92672">**</span> p,x,y; 
p<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>[x]; 
<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>x;<span style="color:#f92672">++</span>i)
{
	p[i]<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[y];
}
</code></pre></div><p><strong>3.动态内存分配</strong></p>
<p><code>char **p;</code>  怎么动态分配内存</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">p<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>[size1];
<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>size1;<span style="color:#f92672">++</span>i){
    p[i]<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[size2];
}
</code></pre></div><p>释放空间的时候，先释放p[i]，最后释放p</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>size1;<span style="color:#f92672">++</span>i){
	<span style="color:#66d9ef">delete</span>[] p[i];
}
<span style="color:#66d9ef">delete</span>[] p;
</code></pre></div><h4 id="005别叫这个大整数已经很简化了">005：别叫，这个大整数已经很简化了!</h4>
<p>1.字符串和整型求和=&gt;sprintf()，把整型转换成字符串，然后两字符串逐位相加。</p>
<p>2.自定义reverse()函数，让对象中字符串逆序存储，以便于逐位相加</p>
<h4 id="ps1问题sizeof和strlen比较">PS1.(问题)sizeof()和strlen()比较</h4>
<p><strong>一句话</strong>：strlen只能字符串数组求元素个数，sizeof求所占空间大小（多少字节）<br>
sizeof 是C++的一个运算符，而 strlen 是一个函数（头文件为cstring）;<br>
sizeof 的操作对象（即操作数operand）可以是数组、指针、类型、对象、函数等，而 strlen 的参数为字符型指针“const char * str”;<br>
sizeof 与 strlen 的返回值类型均为 size_t（即 unsigned int）；<br>
sizeof 的值在编译的时候已经计算好了，而 strlen 是在运行时才计算的。由于是在编译时计算，sizeof 不能用来计算动态分配的内存空间的大小;<br>
strlen 函数实际完成的功能是从 str 字符串的第一个地址开始遍历，直到遇到结束符 NULL（'\0&rsquo;）,返回的字符串长度大小不包括 NULL（'\0&rsquo;）;</p>
<p><strong>sizeof 对于常见的操作数的计算规则如下</strong>：<br>
数组 &ndash; 对数组执行sizeof运算符得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。  <em><strong>注意：sizeof运算不会把数组转换成指针来处理。</strong></em><br>
指针 &ndash; 存储指针所用的空间大小，一般都是固定值，不同于指向变量的指针(解引用指针，*称为解引用符)的大小和其类型有关，“cb中指针占用空间大小（sizeof得到的值）为4”；<br>
类型 &ndash; 指定类型所占的空间大小，如 int 占用4字节（32位）8字节（64位）、char 占用 1 字节；<br>
对象 &ndash; 对象实际占用的空间大小；<br>
函数 &ndash; 函数的返回类型所占的空间大小，如 int 占用8字节。需要注意的是，该函数的返回类型不能是 void。</p>
<h4 id="ps2问题sprintf和atof关系区别">PS2.(问题)sprintf和atof关系、区别</h4>
<p><strong>一句话</strong>：sprintf类似printf用法。</p>
<p><code>sprintf(s, &quot;%d&quot;, 123); //打印整数到字符串</code></p>
<p><code>sprintf(s, &quot;%f&quot;, 3.1415926);//打印浮点数到字符串 </code></p>
<p><code>char* who = &quot;I&quot;; char* whom = &quot;China&quot;; sprintf(s, &quot;%s love %s.&quot;, who, whom); //连接字符串，产生：&quot;I love China. &quot;</code></p>
<p>详见 <a href="https://blog.csdn.net/qq_32175379/article/details/70787885">https://blog.csdn.net/qq_32175379/article/details/70787885</a></p>
<h4 id="ps3数组和指针这道题不必采用动态内存分配直接声明一个较大够用的字符数组这样更方便而且不必担心会出现由浅拷贝造成的runtime-error">PS3.数组和指针，这道题不必采用动态内存分配，直接声明一个较大够用的字符数组，这样更方便而且不必担心会出现由浅拷贝造成的Runtime Error</h4>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
