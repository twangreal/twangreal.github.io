<!doctype html>
<html lang="en-us">
  <head>
    <title>C&#43;&#43;常见知识 // twangreal的博客</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.67.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="twangreal" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://twangreal.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C&#43;&#43;常见知识"/>
<meta name="twitter:description" content="1.结构（C） 结构声明 (structure declaration)
struct book { char title[MAXTITL]; char author[MAXAUTL]; float value; }; struct book library;// 它把 library 声明为一个使用 book 结构设计的结构变量。 对结构使用 typedef:
typedef struct comlex { float real; float imag; } COMPLEX; 这样就可以用类型 COMPLEX 代替 struct complex 来表示复数。
//使用 typedef 来命名一个结构类型时, 可省去结构的标记: typedef struct (double x; double y;) rect; //假设像下面这样使用 typedef 定义的类型名: rect r1 = {3.0, 6.0}; rect r2; r2 = r1; //这被翻译成: struct {double x; double y;} r1 = {3."/>

    <meta property="og:title" content="C&#43;&#43;常见知识" />
<meta property="og:description" content="1.结构（C） 结构声明 (structure declaration)
struct book { char title[MAXTITL]; char author[MAXAUTL]; float value; }; struct book library;// 它把 library 声明为一个使用 book 结构设计的结构变量。 对结构使用 typedef:
typedef struct comlex { float real; float imag; } COMPLEX; 这样就可以用类型 COMPLEX 代替 struct complex 来表示复数。
//使用 typedef 来命名一个结构类型时, 可省去结构的标记: typedef struct (double x; double y;) rect; //假设像下面这样使用 typedef 定义的类型名: rect r1 = {3.0, 6.0}; rect r2; r2 = r1; //这被翻译成: struct {double x; double y;} r1 = {3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://twangreal.github.io/post/c&#43;&#43;%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86/" />
<meta property="article:published_time" content="2020-03-30T16:45:11+08:00" />
<meta property="article:modified_time" content="2020-03-30T16:45:11+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://twangreal.github.io/"><img class="app-header-avatar" src="/personal/cyberpunk1.jpg" alt="twangreal" /></a>
      <h1>twangreal的博客</h1>
      <p>面向对象程序设计基于三个基本概念：数据抽象、继承和动态绑定。  后台开发：编程语言、编译调试、网络通信、常用类库、HTTP协议、进程通信。</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/twangreal" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">C&#43;&#43;常见知识</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Mar 30, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          4 min read
        </div></div>
    </header>
    <div class="post-content">
      <h4 id="1结构c">1.结构（C）</h4>
<p>结构声明 (structure declaration)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> book {
	<span style="color:#66d9ef">char</span> title[MAXTITL];
	<span style="color:#66d9ef">char</span> author[MAXAUTL];
    <span style="color:#66d9ef">float</span> value;
};
<span style="color:#66d9ef">struct</span> book library;<span style="color:#75715e">// 它把 library 声明为一个使用 book 结构设计的结构变量。
</span></code></pre></div><p><strong>对结构使用 typedef:</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> comlex {
	<span style="color:#66d9ef">float</span> real;
	<span style="color:#66d9ef">float</span> imag;
} COMPLEX;
</code></pre></div><p><strong>这样就可以用类型 COMPLEX 代替 struct complex 来表示复数。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//使用 typedef 来命名一个结构类型时, 可省去结构的标记:
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> (<span style="color:#66d9ef">double</span> x; <span style="color:#66d9ef">double</span> y;) rect;

<span style="color:#75715e">//假设像下面这样使用 typedef 定义的类型名:
</span><span style="color:#75715e"></span>rect r1 <span style="color:#f92672">=</span> {<span style="color:#ae81ff">3.0</span>, <span style="color:#ae81ff">6.0</span>};
rect r2;
r2 <span style="color:#f92672">=</span> r1;
<span style="color:#75715e">//这被翻译成:
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> {<span style="color:#66d9ef">double</span> x; <span style="color:#66d9ef">double</span> y;} r1 <span style="color:#f92672">=</span> {<span style="color:#ae81ff">3.0</span>, <span style="color:#ae81ff">6.0</span>};
<span style="color:#66d9ef">struct</span> {<span style="color:#66d9ef">double</span> x; <span style="color:#66d9ef">double</span> y;}  r2;
r2 <span style="color:#f92672">=</span> r1;
</code></pre></div><p><strong>注意</strong>：如果两个结构的声明都不使用标记, 但是使用同样的成员 (成员名和类型都匹配), 那么 C 认为这两个结构具有同样的类型, 因此将 r1 赋给 r2 是一个正确的操作。</p>
<p><strong>PS.</strong>  C++中定义类的关键字“struct” “class”。</p>
<p>格式：关键字 类名  类体。（不同于结构，类名不能省略，类体部分可以为空）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Sales_data</span>{<span style="color:#75715e">/* …… */</span>} accum, trans, <span style="color:#f92672">*</span>salesptr;
<span style="color:#75715e">//与上一条语句等价，但可能更好，建议定义类和定义变量分开！
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Sales_data</span>{<span style="color:#75715e">/* …… */</span>};
Sales_data accum, trans, <span style="color:#f92672">*</span>salesptr;
</code></pre></div><p>C++中定义类struct和class的唯一区别就是<strong>默认的访问权限</strong> ：第一个访问说明符前的成员是public（struct）还是private（class）。</p>
<p><strong>PS2.</strong> 关于定义在类内部的函数是隐式的inline函数。</p>
<h4 id="2静态变量">2.静态变量</h4>
<p>&mdash;全局变量都是静态变量。</p>
<p>&mdash;局部变量定义时如果前面加了“static”关键字，那么该局部变量也是静态变量。</p>
<p>静态变量的存放地址，在整个程序运行期间，都是固定不变的；</p>
<p>非静态变量（一定是局部变量）的 <strong>地址</strong> 在每次函数调用时都可能不同，在函数的一次执行期间不变。</p>
<p><strong>如果未明确初始化，则静态变量会被自动初始化成全0（每个比特都是0），局部非静态变量的值随机。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Func</span>(){
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> n<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span>;<span style="color:#75715e">//静态变量只初始化一次！！
</span><span style="color:#75715e"></span>    cout<span style="color:#f92672">&lt;&lt;</span>n<span style="color:#f92672">&lt;&lt;</span>endl;
    <span style="color:#f92672">++</span>n;
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    Func();Func();Func();<span style="color:#75715e">//4
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;			 <span style="color:#75715e">//5
</span><span style="color:#75715e"></span>}						 <span style="color:#75715e">//6							
</span></code></pre></div><p><strong>静态变量的应用：strtok的实现</strong></p>
<h5 id="strtok的使用">strtok的使用：</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
	<span style="color:#66d9ef">char</span> str[] <span style="color:#f92672">=</span><span style="color:#e6db74">&#34;- This, a sample string, OK.&#34;</span>;
	<span style="color:#75715e">//下面要从str逐个抽取出被&#34; ,.-&#34;这几个字符分隔的字串
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> strtok (str,<span style="color:#e6db74">&#34; ,.-&#34;</span>); 
	<span style="color:#66d9ef">while</span> ( p <span style="color:#f92672">!=</span> NULL){ <span style="color:#75715e">//只要p不为NULL，就说明找到了一个子串
</span><span style="color:#75715e"></span>		cout <span style="color:#f92672">&lt;&lt;</span> p <span style="color:#f92672">&lt;&lt;</span> endl;
		p <span style="color:#f92672">=</span> strtok(NULL, <span style="color:#e6db74">&#34; ,.-&#34;</span>);<span style="color:#75715e">//后续调用，第一个参数必须是NULL
</span><span style="color:#75715e"></span>	}
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>char * strtok( char * s, const char * ct )    strtok 函数在s中搜索由ct中的字符界定的记号。</p>
<p>对strtok( char * s, const char * ct )进行一系列调用，可以把字符串s分成许多记号，这些记号中以ct中的字符为分界符。第一次调用时，s为非空。它搜索s，找到不包含ct中字符的第一个记号，将s中的下一个字符替换为&rsquo;\0&rsquo;，并返回指向记号的指针。随后，每次调用strtok函数时（由s的值是否为NULL指示），均返回下一个不包含ct中字符的记号。当s中没有这样的记号时，返回NULL。<strong>每次调用时字符串ct可以不同。</strong></p>
<h5 id="strtok的实现">strtok的实现：</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">Strtok</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> p,<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> sep){
	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> start ; <span style="color:#75715e">//本次查找子串的起点，局部静态变量！
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>(p)
	start <span style="color:#f92672">=</span> p;
	<span style="color:#66d9ef">for</span>(; <span style="color:#f92672">*</span>start <span style="color:#f92672">&amp;&amp;</span> strchr(sep,<span style="color:#f92672">*</span>start); <span style="color:#f92672">++</span> start); <span style="color:#75715e">//跳过分隔符号
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>( <span style="color:#f92672">*</span> start <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
		<span style="color:#66d9ef">return</span> NULL;
	<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> q <span style="color:#f92672">=</span> start;
	<span style="color:#66d9ef">for</span>(; <span style="color:#f92672">*</span>start <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>strchr(sep,<span style="color:#f92672">*</span>start); <span style="color:#f92672">++</span> start); <span style="color:#75715e">//跳过非分隔符号
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>( <span style="color:#f92672">*</span> start) {
		<span style="color:#f92672">*</span> start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
		<span style="color:#f92672">++</span> start;
	}
	<span style="color:#66d9ef">return</span> q;
}
</code></pre></div><p>PS. char* strchr (const char*, int)来查找字符串中是否有符合的字符。</p>
<h4 id="3数组一般不要定义在main里尤其是大数组">3.<strong>数组一般不要定义在main里，尤其是大数组。</strong></h4>
<p>全局变量在 <strong>静态存储区</strong> 分配内存，局部变量是在 <strong>栈</strong> 上分配内存空间的。（c语言程序在运行时会动态创建一个堆栈段，里面存放着调用栈，保存着函数的调用关系和局部变量。）如果数组太大，可能会造成栈溢出。所以最好在mian 函数外部定义这个大数组。</p>
<h4 id="4位运算">4.位运算</h4>
<p>异或^  ：0^0=0, 1^1=0, 0^1=1, 1^0=1</p>
<p>&ldquo;&raquo;&quot;右移n位，（等价于“除以2的n次方，在往 <strong>小</strong> 取整”）</p>
<p>&ldquo;&laquo;&quot;左移n位，（等价于“乘以2的n次方）</p>
<h4 id="5输入输出相关cgetsgetcgetcharscanf">5.输入输出相关（C:gets、getc、getchar、scanf）</h4>
<p>​	(1) <code>char line[20]; scanf(&quot;%s&quot;,line);</code> 字符串数组名前不加&amp;，其他类型数组如int、double要加&amp;  。</p>
<p>​	(2) <code>cin.get();/ scanf(&quot;%c&quot;,&amp;c);/getchar()</code>输入一个字符，<strong>均可读取空格、回车符等</strong></p>
<p>c=cin.get(); 或 cin.get(c);</p>
<p><strong>int getchar(void);</strong></p>
<p>char c;</p>
<p>while((c=cin.get())!=EOF){}</p>
<p>while((c=getchar())!=EOF){}</p>
<p>while(scanf(&quot;%c&rdquo;,&amp;c)!=EOF){}</p>
<p>注意：不要同时使用cin、scanf，也不要同时使用cout、printf ！</p>
<p><em><em>int  getc (FILE</em> __F)</em>* 从文件读入一个字符，</p>
<p>getc(stdin)等价于getchar()等价于scanf(&quot;%c&rdquo;,&amp;c)等价于cin.get()</p>
<h5 id="3-gets">(3) gets</h5>
<p>gets() 函数的功能是从输入缓冲区中读取一个字符串存储到字符指针变量 str 所指向的内存空间。</p>
<p><em><em>char</em> gets (char</em>  str);**</p>
<p>从标准输入 stdin 读取一行，并把它存储在 str 所指向的字符串中。(可以读取字符串中可以有空格)</p>
<p>如果成功，该函数返回 str。如果发生错误或者到达文件末尾时还未读取任何字符，则返回 NULL。</p>
<p>注意：避免数组越界！</p>
<p>注意： gets() 会读取换行符，但 <strong>不会</strong> 存储到str中。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e"># include &lt;stdio.h&gt;
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
{
    <span style="color:#66d9ef">char</span> str[<span style="color:#ae81ff">30</span>];
    <span style="color:#66d9ef">char</span> ch;
    printf(<span style="color:#e6db74">&#34;请输入字符串：&#34;</span>);
    gets(str);
    printf(<span style="color:#e6db74">&#34;%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, str);
    scanf(<span style="color:#e6db74">&#34;%c&#34;</span>, <span style="color:#f92672">&amp;</span>ch);
    printf(<span style="color:#e6db74">&#34;ch = %c</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ch);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#75715e">//输出结果是：
</span><span style="color:#75715e">//请输入字符串：i love you
</span><span style="color:#75715e">//i love you
</span><span style="color:#75715e">//Y
</span><span style="color:#75715e">//ch = Y
</span></code></pre></div><p>(4) cin.get 和 cin.getline详见 <a href="https://twangreal.github.io/post/week7_c++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9B%B8%E5%85%B3/">week7_C++输入输出相关</a></p>
<h4 id="6函数返回值-t">6.函数返回值 T&amp;</h4>
<p>P246  返回*this的成员函数（-&gt; P200 6.3.2有返回值函数）</p>
<p>P202 引用返回左值（P121 左值和右值）</p>
<h4 id="7有符号整数">7.有符号整数</h4>
<p>首位时符号位，负1正0</p>
<p>余下位为 数的绝对值二进制码 <strong>取反</strong> ，再加1。</p>
<p>例：1 0x00000001   -1 0x11111111</p>
<p>注意：整数溢出可预测，浮点数不行</p>
<p>溢出部分丢弃</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">unsighed <span style="color:#66d9ef">int</span> n1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xffffffff</span>;
<span style="color:#66d9ef">int</span> n2<span style="color:#f92672">=</span>n1<span style="color:#f92672">+</span><span style="color:#ae81ff">3</span>;<span style="color:#75715e">//溢出，n2为0x ‘1’ 00000002，丢弃溢出的那一位，剩下0x00000002
</span><span style="color:#75715e">//所以n2的值为2
</span></code></pre></div><p>PS.数据类型精度（从高到低）</p>
<p>double&gt;long long&gt;int&gt;short&gt;char</p>
<h4 id="8字符型常量">8.字符型常量</h4>
<p>’a&rsquo;,&lsquo;A'等</p>
<p><img src="https://twangreal.github.io/C++_image/zifuchangliang.jpg" alt="'\n&rsquo;,'\r&rsquo;,'\t&rsquo;,'\b&rsquo;,'\\','\'','\0&rsquo;,'\ddd&rsquo;,'\xhh&rsquo;"></p>
<p>字符串常量：是用双引号括起来的一串字符  &ldquo;abc&rdquo;, &ldquo;a&rdquo;, &ldquo;123456&rdquo;</p>
<p>符号常量 ：常用一个由字母和数字组成的 <strong>符号</strong> 来代表某个常量</p>
<p>例如：#define MAX_NUM 1000</p>
<p>#define MYINT i=5；  //</p>
<p>注意：避免直接再程序中使用数值常量，而用符号常量来替代，这样便于修改。</p>
<h4 id="9和-是-短路计算-的">9.&amp;&amp;和|| 是 <strong>短路计算</strong> 的。</h4>
<h4 id="10字符串库函数stringh">10.字符串库函数&lt;string.h&gt;</h4>
<p>头文件&lt;string.h&gt;中定义了两组字符串函数：一组str开头，一组mem开头。</p>
<p>第一组：s 和 t 的类型为 char *； cs 和 ct 的类型为 const char * ；n 的类型为 size_t ；c 的类型为 int（将被转换成 char 类型）。</p>
<p><img src="https://twangreal.github.io/C++_image/string_func1.jpg" alt=""></p>
<p><img src="https://twangreal.github.io/C++_image/string_func2.jpg" alt=""></p>
<p>第二组：s 和 t 的类型均为 void * ，cs 和 ct 均为 const * ，n的类型为 size_t ，c的类型为 int（将被转换成 unsigned char 类型）。</p>
<p><img src="https://twangreal.github.io/C++_image/string_func3.jpg" alt=""></p>
<h4 id="11指针和数组">11.指针和数组</h4>
<p>见 <a href="https://twangreal.github.io/post/C++%E6%8C%87%E9%92%88/">C++指针</a></p>
<h4 id="12typedef">12.typedef</h4>
<p>//……</p>
<h4 id="13atof和sprintf">13.atof和sprintf</h4>
<p>一句话**：sprintf类似printf用法。</p>
<p><code>sprintf(s, &quot;%d&quot;, 123); //打印整数到字符串</code></p>
<p><code>sprintf(s, &quot;%f&quot;, 3.1415926);//打印浮点数到字符串 </code></p>
<p><code>char* who = &quot;I&quot;; char* whom = &quot;China&quot;; sprintf(s, &quot;%s love %s.&quot;, who, whom); //连接字符串，产生：&quot;I love China. &quot;</code></p>
<p>详见 <a href="https://blog.csdn.net/qq_32175379/article/details/70787885">https://blog.csdn.net/qq_32175379/article/details/70787885</a></p>
<h4 id="14sort和qsort">14.sort和qsort</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;cstdlib&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">qsort</span>( <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>base, size_t n_element, size_t el_size, <span style="color:#75715e">//四个参数， 需要排序的数组，
</span><span style="color:#75715e"></span>           <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>compare)(<span style="color:#66d9ef">void</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span> ) );<span style="color:#75715e">//元素个数，元素长度，函数指针
</span></code></pre></div><p>函数指针应用的函数的返回值，大于零、等于零、小于零 分别表示 第1个参数 大于、等于、小于 第2个参数（PS小的参数排在前；如果要求从大到小排序，就需要对返回值进行一定的处理）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort</span>(RandomAccessIterator beg, RandomAccessIterator end);<span style="color:#75715e">//P596
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort</span>(RandomAccessIterator beg, RandomAccessIterator end, BinaryPredicate op);
<span style="color:#75715e">//范围[beg,end)，可用于数组、容器
</span><span style="color:#75715e">//binaryPredicate 双参判断式：1.两个参数的cmp函数；2.函数对象（function object）来实现一个排序准则
</span><span style="color:#75715e">//C++标准库第2版P476，  例如
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PersonSortCriterion</span>{
    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span>() (<span style="color:#66d9ef">const</span> Person<span style="color:#f92672">&amp;</span> p1, <span style="color:#66d9ef">const</span> Person<span style="color:#f92672">&amp;</span> p2) <span style="color:#66d9ef">const</span> {
        <span style="color:#66d9ef">return</span> p1.lastname()<span style="color:#f92672">&lt;</span>p2.lastname() <span style="color:#f92672">||</span> .......  ;
    }
}<span style="color:#75715e">//class for function prediacate
</span><span style="color:#75715e">//这个函数判断式的类不仅可以用于sort、stable_sort，还能用于set等 作为排序准则
</span><span style="color:#75715e"></span>set<span style="color:#f92672">&lt;</span>Person, PersonSortCriterion<span style="color:#f92672">&gt;</span> coll;

<span style="color:#75715e">//stable_sort，和sort区别：stable_sort保证相等的各元素相对次序再排序后保持不变
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">stable_sort</span>(RandomAccessIterator beg, RandomAccessIterator end);
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">stable_sort</span>(RandomAccessIterator beg, RandomAccessIterator end, BinaryPredicate op);
</code></pre></div><h4 id="15extern-c">15.extern C</h4>
<p>//&hellip;&hellip;..</p>
<h4 id="16maxelement-函数">16.*maxelement 函数</h4>
<p>//，，，，</p>
<h4 id="17常量迭代器">17.常量迭代器</h4>
<p>即 不能通过常量迭代器 修改其指向的对象。（但是可以通用其它的 非常量迭代器 来修改该对象）</p>
<p>PS. 迭代器都可以进行 ++ 操作。</p>
<table>
<thead>
<tr>
<th>迭代器种类</th>
<th>支持的操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>正向迭代器</td>
<td>++p, p++, *p, ==, !=</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>正向迭代器的操作  加上  &ndash;p, p&ndash;</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>双向迭代器的操作  加上  p+=i, p-=i, p+i, p-i, p[i]   （i 是一个整型变量或常量）</td>
</tr>
</tbody>
</table>
<h4 id="18模板">18.模板</h4>
<p>在模板中写迭代器时，最好在前面加上 typename关键字，否则可能会编译错。VS可能无此问题，但是Dev C++和服务器上的编译环境会有这个问题。</p>
<h4 id="19make_pair">19.make_pair</h4>
<p>make_pair(val1, val2) //返回一个pair，带有 val1 和val2 的类型和数值</p>
<p>例如：std::make_pair(42,'@') 效果等价于 std::pair&lt;int,char&gt;(42,'@')</p>
<p>PS.关于pair，见C++标准库第2版 P61</p>
<h4 id="20容器">20.容器</h4>
<p>set容器中元素的值不能改变，map容器中元素的关键字成员不能改变。</p>
<p>因为set和map中不能有重复元素，这些值如果可以改变，那么再容器中就可能出现重复元素，所以这些值被设定为read-only</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
