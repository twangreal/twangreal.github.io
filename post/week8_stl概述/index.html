<!doctype html>
<html lang="en-us">
  <head>
    <title>Week8_STL概述 // twangreal的博客</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.67.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="twangreal" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://twangreal.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Week8_STL概述"/>
<meta name="twitter:description" content="一、泛型程序设计 C&#43;&#43; 语言的核心优势之一就是便于软件的 重用 。
C&#43;&#43;中有两个方面体现重用：
​	1.面向对象的思想：继承和多态，标准类库
​	2.泛型程序设计(generic programming) 的思想： 模板机制，以及标准模板库 STL
简单地说就是使用 模板 的程序设计法。
将一些常用的 数据结构 （比如链表，数组，二叉树）和 算法 （比如排序，查找）写成 模板 ，以后则不论数据结构里放的是什么对象，算法针对什么样的对象，则都不必重新实现数据结构，重新编写算法。
标准模板库 (Standard Template Library) 就是一些 常用数据结构和算法的模板的集合 。有了STL，不必再写大多的标准数据结构和算法，并且可获得非常高的性能。
二、STL中的基本的概念 容器：可容纳各种数据类型的通用数据结构,是 类模板
迭代器：可用于依次存取容器中元素，类似于 指针
算法：用来操作容器中的元素的 函数模板
&mdash;sort()来对一个vector中的数据进行排序
&mdash;find()来搜索一个list中的对象
算法本身与他们操作的数据的类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用。
例如：
int array[100]; //该数组就是容器，而 int * 类型的指针变量就可以作为迭代器，sort算法可以作用于该容器上，对其进行排序： sort(array,array&#43;70); //将前70个元素排序 三、容器概述 可以用于存放各种类型的数据（基本类型的变量，对象等）的数据结构，都是 类模版 ，分为三种：
​	1)顺序容器 ： vector, deque,list
​	2)关联容器 ： set, multiset, map, multimap
​	3)容器适配器 ： stack, queue, priority_queue"/>

    <meta property="og:title" content="Week8_STL概述" />
<meta property="og:description" content="一、泛型程序设计 C&#43;&#43; 语言的核心优势之一就是便于软件的 重用 。
C&#43;&#43;中有两个方面体现重用：
​	1.面向对象的思想：继承和多态，标准类库
​	2.泛型程序设计(generic programming) 的思想： 模板机制，以及标准模板库 STL
简单地说就是使用 模板 的程序设计法。
将一些常用的 数据结构 （比如链表，数组，二叉树）和 算法 （比如排序，查找）写成 模板 ，以后则不论数据结构里放的是什么对象，算法针对什么样的对象，则都不必重新实现数据结构，重新编写算法。
标准模板库 (Standard Template Library) 就是一些 常用数据结构和算法的模板的集合 。有了STL，不必再写大多的标准数据结构和算法，并且可获得非常高的性能。
二、STL中的基本的概念 容器：可容纳各种数据类型的通用数据结构,是 类模板
迭代器：可用于依次存取容器中元素，类似于 指针
算法：用来操作容器中的元素的 函数模板
&mdash;sort()来对一个vector中的数据进行排序
&mdash;find()来搜索一个list中的对象
算法本身与他们操作的数据的类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用。
例如：
int array[100]; //该数组就是容器，而 int * 类型的指针变量就可以作为迭代器，sort算法可以作用于该容器上，对其进行排序： sort(array,array&#43;70); //将前70个元素排序 三、容器概述 可以用于存放各种类型的数据（基本类型的变量，对象等）的数据结构，都是 类模版 ，分为三种：
​	1)顺序容器 ： vector, deque,list
​	2)关联容器 ： set, multiset, map, multimap
​	3)容器适配器 ： stack, queue, priority_queue" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://twangreal.github.io/post/week8_stl%E6%A6%82%E8%BF%B0/" />
<meta property="article:published_time" content="2020-04-07T13:57:25+08:00" />
<meta property="article:modified_time" content="2020-04-07T13:57:25+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://twangreal.github.io/"><img class="app-header-avatar" src="/personal/cyberpunk1.jpg" alt="twangreal" /></a>
      <h1>twangreal的博客</h1>
      <p>面向对象程序设计基于三个基本概念：数据抽象、继承和动态绑定。  后台开发：编程语言、编译调试、网络通信、常用类库、HTTP协议、进程通信。</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/twangreal" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Week8_STL概述</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Apr 7, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          4 min read
        </div></div>
    </header>
    <div class="post-content">
      <h3 id="一泛型程序设计">一、泛型程序设计</h3>
<p>C++ 语言的核心优势之一就是便于软件的 <strong>重用</strong> 。</p>
<p>C++中有两个方面体现重用：</p>
<p>​	1.面向对象的思想：继承和多态，标准类库<br>
​	2.泛型程序设计(generic programming) 的思想： 模板机制，以及标准模板库 STL</p>
<p>简单地说就是使用 <strong>模板</strong> 的程序设计法。</p>
<p>将一些常用的 <strong>数据结构</strong> （比如链表，数组，二叉树）和 <strong>算法</strong> （比如排序，查找）写成 <strong>模板</strong> ，以后则不论数据结构里放的是什么对象，算法针对什么样的对象，则都不必重新实现数据结构，重新编写算法。</p>
<p><strong>标准模板库 (Standard Template Library)</strong>  就是一些 <strong>常用数据结构和算法的模板的集合</strong> 。有了STL，不必再写大多的标准数据结构和算法，并且可获得非常高的性能。</p>
<h3 id="二stl中的基本的概念">二、STL中的基本的概念</h3>
<p>容器：可容纳各种数据类型的通用数据结构,是 <strong>类模板</strong></p>
<p>迭代器：可用于依次存取容器中元素，类似于 <strong>指针</strong></p>
<p>算法：用来操作容器中的元素的 <strong>函数模板</strong></p>
<p>&mdash;sort()来对一个vector中的数据进行排序</p>
<p>&mdash;find()来搜索一个list中的对象</p>
<p>算法本身与他们操作的数据的类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用。</p>
<p>例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> array[<span style="color:#ae81ff">100</span>];
<span style="color:#75715e">//该数组就是容器，而 int * 类型的指针变量就可以作为迭代器，sort算法可以作用于该容器上，对其进行排序：
</span><span style="color:#75715e"></span>sort(array,array<span style="color:#f92672">+</span><span style="color:#ae81ff">70</span>); <span style="color:#75715e">//将前70个元素排序
</span></code></pre></div><h3 id="三容器概述">三、容器概述</h3>
<p>可以用于存放各种类型的数据（基本类型的变量，对象等）的数据结构，都是 <strong>类模版</strong> ，分为三种：</p>
<p>​	1)顺序容器 ： vector, deque,list</p>
<p>​	2)关联容器 ： set, multiset, map, multimap</p>
<p>​	3)容器适配器 ： stack, queue, priority_queue</p>
<p>对象被插入容器中时，被插入的是对象的一个复制品。</p>
<p>许多算法，比如排序，查找，要求对容器中的元素进行比较，有的容器本身就是排序的，所以，放入容器的对象所属的类，往往还应该重载 == 和 &lt; 运算符。</p>
<h4 id="1顺序容器简介">1.顺序容器简介</h4>
<p><strong>元素并非排序的</strong> ，元素的插入位置同元素的值无关。（vector,deque,list 三种）</p>
<ul>
<li>vector   头文件 <!-- raw HTML omitted -->
<ul>
<li><strong>动态数组</strong> 。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能(大部分情况下是常数时间）。</li>
</ul>
</li>
<li>deque   头文件 <!-- raw HTML omitted -->
<ul>
<li><strong>双向队列</strong> 。元素在内存连续存放。随机存取任何元素都能在常数时间完成( 但次于vector )。在两端增删元素具有较佳的性能(大部分情况下是常数时间）。</li>
</ul>
</li>
<li>list   头文件 <!-- raw HTML omitted -->
<ul>
<li><strong>双向链表</strong> 。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。</li>
</ul>
</li>
</ul>
<h4 id="2关联容器简介">2.关联容器简介</h4>
<p><strong>元素是排序的 。</strong></p>
<ul>
<li>
<p>插入任何元素，都按相应的排序规则来确定其位置</p>
</li>
<li>
<p>在查找时具有非常好的性能</p>
</li>
<li>
<p>通常以平衡二叉树方式实现，插入和检索的时间都是 O(log(N))</p>
</li>
<li>
<p>set/multiset 头文件 <!-- raw HTML omitted -->
set 即集合。</p>
</li>
<li>
<p>set中不允许相同元素；</p>
</li>
<li>
<p>multiset中允许存在相同的元素。</p>
</li>
<li>
<p>map/multimap 头文件 <!-- raw HTML omitted --></p>
</li>
<li>
<p>map与set的不同在于 <strong>map中存放的元素有且仅有两个成员变量</strong> ，一个名为first,另一个名为second, map根据first值对元素进行从小到大排序，并可快速地根据first来检索元素。</p>
</li>
<li>
<p>map同multimap的不同在于是否允许相同first值的元素。</p>
</li>
</ul>
<h4 id="3容器适配器简介">3.容器适配器简介</h4>
<ul>
<li>
<p>stack  头文件 <!-- raw HTML omitted --></p>
</li>
<li>
<p>栈。是项的有限序列，并满足序列中被删除、检索和修改的项只能是最近插入序列的项（栈顶的项）。后进先出。</p>
</li>
<li>
<p>queue  头文件 <!-- raw HTML omitted --></p>
<ul>
<li>队列。插入只可以在尾部进行，删除、检索和修改只允许从头部进行。先进先出。</li>
</ul>
</li>
<li>
<p>priority_queue  头文件 <!-- raw HTML omitted --></p>
<ul>
<li>优先级队列。最高优先级元素总是第一个出列</li>
</ul>
</li>
</ul>
<h4 id="4顺序容器和关联容器中都有的成员函数">4.顺序容器和关联容器中都有的成员函数</h4>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>begin</td>
<td>返回指向容器中第一个元素的迭代器</td>
</tr>
<tr>
<td>end</td>
<td>返回指向容器中最后一个元素后面的位置的迭代器</td>
</tr>
<tr>
<td>rbegin</td>
<td>返回指向容器中最后一个元素的迭代器</td>
</tr>
<tr>
<td>rend</td>
<td>返回指向容器中第一个元素前面的位置的迭代器</td>
</tr>
<tr>
<td>erase</td>
<td>从容器中删除一个或几个元素</td>
</tr>
<tr>
<td>clear</td>
<td>从容器中删除所有元素</td>
</tr>
</tbody>
</table>
<h4 id="5顺序容器的常用成员函数">5.顺序容器的常用成员函数</h4>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>front</td>
<td>返回容器中第一个元素的引用</td>
</tr>
<tr>
<td>back</td>
<td>返回容器中最后一个元素的引用</td>
</tr>
<tr>
<td>push_back</td>
<td>在容器末尾增加新元素</td>
</tr>
<tr>
<td>pop_back</td>
<td>删除容器末尾的元素</td>
</tr>
<tr>
<td>erase</td>
<td>删除迭代器指向的元素(可能会使该迭代器失效），或删除一个区间，返回被删除元素后面的那个元素的迭代器</td>
</tr>
</tbody>
</table>
<h3 id="四迭代器">四、迭代器</h3>
<h4 id="1基本概念">1.基本概念</h4>
<ul>
<li>
<p>用于指向顺序容器和关联容器中的元素。</p>
</li>
<li>
<p>迭代器用法和指针类似</p>
</li>
<li>
<p>有const 和非 const两种</p>
</li>
<li>
<p>通过迭代器可以读取它指向的元素</p>
</li>
<li>
<p>通过非const迭代器还能修改其指向的元素</p>
</li>
</ul>
<h4 id="2定义一个容器类的迭代器的方法可以是">2.定义一个容器类的迭代器的方法可以是：</h4>
<ul>
<li>访问一个迭代器指向的元素：</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#960050;background-color:#1e0010">容器类名</span><span style="color:#f92672">::</span>iterator <span style="color:#960050;background-color:#1e0010">变量名</span>;
<span style="color:#75715e">//或：
</span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">容器类名</span><span style="color:#f92672">::</span>const_iterator <span style="color:#960050;background-color:#1e0010">变量名</span>;
</code></pre></div><ul>
<li>访问一个迭代器指向的元素：</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">迭代器变量名</span>
</code></pre></div><p>迭代器上可以执行 ++ 操作, 以使其指向容器中的下一个元素。如果迭代器到达了容器中的最后一个元素的后面，此时再使用它，就会出错，类似于使用NULL或未初始化的指针一样。</p>
<h4 id="3迭代器示例">3.迭代器示例</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
	vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v; <span style="color:#75715e">//一个存放int元素的数组，一开始里面没有元素
</span><span style="color:#75715e"></span>	v.push_back(<span style="color:#ae81ff">1</span>);<span style="color:#75715e">//插入
</span><span style="color:#75715e"></span>    v.push_back(<span style="color:#ae81ff">2</span>); 
    v.push_back(<span style="color:#ae81ff">3</span>); 
	v.push_back(<span style="color:#ae81ff">4</span>);
	vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>const_iterator i; <span style="color:#75715e">//常量迭代器——不能通过常量迭代器区修改指向的对象；但对象可以被其他的非常量迭代器修改，
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span>( i <span style="color:#f92672">=</span> v.begin();i <span style="color:#f92672">!=</span> v.end();<span style="color:#f92672">++</span>i ) 
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;,&#34;</span>;
	cout <span style="color:#f92672">&lt;&lt;</span> endl;
	vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>reverse_iterator r; <span style="color:#75715e">//反向迭代器
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span>( r <span style="color:#f92672">=</span> v.rbegin();r <span style="color:#f92672">!=</span> v.rend();r<span style="color:#f92672">++</span> ) <span style="color:#75715e">//反向迭代器中 “++操作” 是从后往前的 
</span><span style="color:#75715e"></span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span> r <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;,&#34;</span>;
	cout <span style="color:#f92672">&lt;&lt;</span> endl;
	vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator j; <span style="color:#75715e">//非常量迭代器
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span>( j <span style="color:#f92672">=</span> v.begin();j <span style="color:#f92672">!=</span> v.end();j <span style="color:#f92672">++</span> ) 
		<span style="color:#f92672">*</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>;            <span style="color:#75715e">//修改了数组中元素的值
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span>( i <span style="color:#f92672">=</span> v.begin();i <span style="color:#f92672">!=</span> v.end();i<span style="color:#f92672">++</span> ) 
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;,&#34;</span>;
}
<span style="color:#75715e">//迭代器示例
</span><span style="color:#75715e">//输出结果：
</span><span style="color:#75715e">//1,2,3,4,
</span><span style="color:#75715e">//4,3,2,1,
</span><span style="color:#75715e">//100,100,100,100,
</span></code></pre></div><h4 id="4双向迭代器">4.双向迭代器</h4>
<p>若p和p1都是双向迭代器，则可对p、p1可进行以下操作：</p>
<p>1.++p, p++ 使p指向容器中下一个元素</p>
<p>2.&ndash;p, p&ndash; 使p指向容器中上一个元素</p>
<p>3.*p 取p指向的元素</p>
<p>4.p = p1 赋值</p>
<p>5.p == p1 , p!= p1 判断是否相等、不等</p>
<h4 id="5随机访问迭代器">5.随机访问迭代器</h4>
<p>若p和p1都是随机访问迭代器，则可对p、p1可进行以下操作：</p>
<p>1.双向迭代器的所有操作<br>
2.p += i 将p向后移动 i 个元素<br>
3.p -= i 将p向向前移动 i 个元素<br>
4.p + i 值为: 指向 p 后面的第 i 个元素的迭代器<br>
5.p - i 值为: 指向 p 前面的第 i 个元素的迭代器<br>
6.p[i] 值为: p后面的第 i 个元素的引用<br>
7.p &lt; p1, p &lt;= p1, p &gt; p1, p&gt;= p1<br>
8.p – p1 : p1和p之间的元素个数</p>
<h4 id="6容器">6.容器</h4>
<table>
<thead>
<tr>
<th align="left">容器</th>
<th>容器上的迭代器类别</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">vector</td>
<td>随机访问</td>
</tr>
<tr>
<td align="left">deque</td>
<td>随机访问</td>
</tr>
<tr>
<td align="left">list</td>
<td>双向</td>
</tr>
<tr>
<td align="left">set/multiset</td>
<td>双向</td>
</tr>
<tr>
<td align="left">map/multimap</td>
<td>双向</td>
</tr>
<tr>
<td align="left">stack</td>
<td>不支持迭代器</td>
</tr>
<tr>
<td align="left">queque</td>
<td>不支持迭代器</td>
</tr>
<tr>
<td align="left">priority_queue</td>
<td>不支持迭代器</td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong> 有的算法，例如sort，binary_search需要通过 <strong>随机访问迭代器</strong> 来访问容器中的元素，那么list以及关联容器就不支持该算法。</p>
<p>例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">//vector的迭代器是随机迭代器，
</span><span style="color:#75715e">//遍历 vector 可以有以下几种做法(deque亦然)：
</span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v(<span style="color:#ae81ff">100</span>); 
<span style="color:#66d9ef">int</span> i;
<span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> v.size() ; i <span style="color:#f92672">++</span>)<span style="color:#75715e">//一
</span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> v[i]; <span style="color:#75715e">//根据下标随机访问
</span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>const_iterator ii;
<span style="color:#66d9ef">for</span>( ii <span style="color:#f92672">=</span> v.begin(); ii <span style="color:#f92672">!=</span> v.end ();<span style="color:#f92672">++</span>ii)<span style="color:#75715e">//二
</span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span> ii;
<span style="color:#66d9ef">for</span>( ii <span style="color:#f92672">=</span> v.begin(); ii <span style="color:#f92672">&lt;</span> v.end ();<span style="color:#f92672">++</span>ii )<span style="color:#75715e">//三
</span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span> ii;
<span style="color:#75715e">//间隔一个输出：
</span><span style="color:#75715e"></span>ii <span style="color:#f92672">=</span> v.begin();
<span style="color:#66d9ef">while</span>( ii <span style="color:#f92672">&lt;</span> v.end()) {
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span> ii; 
	ii <span style="color:#f92672">=</span> ii <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>; 
}

<span style="color:#75715e">//list 的迭代器是双向迭代器，
</span><span style="color:#75715e">//正确的遍历list的方法：
</span><span style="color:#75715e"></span>list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v;
list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>const_iterator ii;
<span style="color:#66d9ef">for</span>( ii <span style="color:#f92672">=</span> v.begin(); ii <span style="color:#f92672">!=</span> v.end ();<span style="color:#f92672">++</span>ii )<span style="color:#75715e">//双向迭代器支持！=
</span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span> ii;
<span style="color:#75715e">//错误的做法：
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span>( ii <span style="color:#f92672">=</span> v.begin(); ii <span style="color:#f92672">&lt;</span> v.end ();<span style="color:#f92672">++</span>ii )<span style="color:#75715e">//一，双向迭代器不支持 &lt; 
</span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span> ii;
<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> v.size() ; i <span style="color:#f92672">++</span>)<span style="color:#75715e">//双向迭代器不支持 &lt;
</span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> v[i];    <span style="color:#75715e">//二，list没有 [] 成员函数
</span></code></pre></div><h3 id="五算法简介">五、算法简介</h3>
<h4 id="1算法简介">1.算法简介</h4>
<ul>
<li>
<p>算法就是一个个 <strong>函数模板</strong> , 大多数在<!-- raw HTML omitted --> 中定义。</p>
</li>
<li>
<p>STL中提供能在各种容器中通用的算法，比如查找，排序等。</p>
</li>
<li>
<p>算法通过迭代器来操纵容器中的元素。</p>
<ul>
<li>许多算法可以对容器中的一个局部区间进行操作，因此需要两个参数，一个是起始元素的迭代器，一个是终止元素的后面一个元素的迭代器。比如，排序和查找。</li>
</ul>
</li>
<li>
<p>有的算法返回一个迭代器。比如 find() 算法，在容器中查找一个元素，并返回一个指向该元素的迭代器。</p>
</li>
<li>
<p>算法可以处理容器，也可以处理普通数组。</p>
</li>
</ul>
<h4 id="2算法示例find">2.算法示例：find()</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InIt</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
InIt find(InIt first, InIt last, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> val);
</code></pre></div><ul>
<li>first 和 last 这两个参数都是容器的迭代器，它们给出了容器中的查找区间起点和终点[first,last)。区间的起点是位于查找范围之中的，而终点不是。find在[first,last)查找等于val的元素</li>
<li>用 == 运算符判断相等</li>
<li>函数返回值是一个迭代器。如果找到，则该迭代器指向被找到的元素；如果找不到，则该迭代器等于last</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() { <span style="color:#75715e">//find算法示例
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> array[<span style="color:#ae81ff">10</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">20</span>,<span style="color:#ae81ff">30</span>,<span style="color:#ae81ff">40</span>};
	vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v;
	v.push_back(<span style="color:#ae81ff">1</span>); v.push_back(<span style="color:#ae81ff">2</span>);<span style="color:#75715e">//插入
</span><span style="color:#75715e"></span>	v.push_back(<span style="color:#ae81ff">3</span>); v.push_back(<span style="color:#ae81ff">4</span>);<span style="color:#75715e">//插入 =》 vector容器v中有 1，2，3，4
</span><span style="color:#75715e"></span>	vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator p;  <span style="color:#75715e">//迭代器
</span><span style="color:#75715e"></span>	p <span style="color:#f92672">=</span> find(v.begin(),v.end(),<span style="color:#ae81ff">3</span>);<span style="color:#75715e">//v 中找 3 ，找到返回指向3的迭代器
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>( p <span style="color:#f92672">!=</span> v.end())
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span> p <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">//输出3
</span><span style="color:#75715e"></span>	p <span style="color:#f92672">=</span> find(v.begin(),v.end(),<span style="color:#ae81ff">9</span>);<span style="color:#75715e">//v 中找 9，没找到，返回 v.end()
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>( p <span style="color:#f92672">==</span> v.end())
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;not found &#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">//输出
</span><span style="color:#75715e"></span>	p <span style="color:#f92672">=</span> find(v.begin()<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,v.end()<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>); <span style="color:#75715e">//整个容器：[1,2,3,4]， 查找区间：[2,3)
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>( p <span style="color:#f92672">!=</span> v.end())             <span style="color:#75715e">//显然找不到 1， 此时的end是3
</span><span style="color:#75715e"></span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span> p <span style="color:#f92672">&lt;&lt;</span> endl;       <span style="color:#75715e">//所以 *p 输出 3
</span><span style="color:#75715e"></span>	
    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span> pp <span style="color:#f92672">=</span> find( array,array<span style="color:#f92672">+</span><span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">20</span>);<span style="color:#75715e">// 数组名是迭代器
</span><span style="color:#75715e"></span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span> pp <span style="color:#f92672">&lt;&lt;</span> endl;
}
</code></pre></div><h3 id="六stl中的大小和相等">六、STL中的“大”、“小”和“相等”</h3>
<h4 id="1stl中大小-的概念">1.STL中“大”“小” 的概念</h4>
<ul>
<li>关联容器内部的元素是从小到大排序的</li>
<li>有些算法要求其操作的区间是从小到大排序的，称为“有序区间算法”
<ul>
<li>例：binary_search</li>
</ul>
</li>
<li>有些算法会对区间进行从小到大排序，称为“排序算法”
<ul>
<li>例： sort</li>
</ul>
</li>
<li>还有一些其他算法会用到“大”，“小”的概念</li>
</ul>
<p>**注意：**使用STL时，在 <strong>缺省</strong> 的情况下，以下三个说法等价：1)  x 比 y 小； 2)  表达式 “x&lt;y” 为真； 3)  y 比 x 大。</p>
<h4 id="2stl中相等的概念">2.STL中“相等”的概念</h4>
<ul>
<li>
<p>有时，“x和y相等”等价于“x==y为真”</p>
<ul>
<li>例：在未排序的区间上进行的算法，如顺序查找find</li>
</ul>
</li>
<li>
<p>时“x和y相等”等价于“x小于y和y小于x同时为假”</p>
<ul>
<li>例：（1）有序区间算法，如binary_search；（2）关联容器自身的成员函数find</li>
</ul>
</li>
<li>
<p>STL中“相等” 概念演示</p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
	<span style="color:#66d9ef">int</span> v;
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	A(<span style="color:#66d9ef">int</span> n)<span style="color:#f92672">:</span>v(n) { }
	<span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span> <span style="color:#f92672">&lt;</span> ( <span style="color:#66d9ef">const</span> A <span style="color:#f92672">&amp;</span> a2) <span style="color:#66d9ef">const</span> { 
		<span style="color:#75715e">//必须为常量成员函数
</span><span style="color:#75715e"></span>		cout <span style="color:#f92672">&lt;&lt;</span> v <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;&lt;&#34;</span> <span style="color:#f92672">&lt;&lt;</span> a2.v <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;?&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
		<span style="color:#66d9ef">return</span> false; 
    }
	<span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span> <span style="color:#f92672">==</span>(<span style="color:#66d9ef">const</span> A <span style="color:#f92672">&amp;</span> a2) <span style="color:#66d9ef">const</span> {
		cout <span style="color:#f92672">&lt;&lt;</span> v <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;==&#34;</span> <span style="color:#f92672">&lt;&lt;</span> a2.v <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;?&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
		<span style="color:#66d9ef">return</span> v <span style="color:#f92672">==</span> a2.v;
	}
};
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
	A a [] <span style="color:#f92672">=</span> { A(<span style="color:#ae81ff">1</span>),A(<span style="color:#ae81ff">2</span>),A(<span style="color:#ae81ff">3</span>),A(<span style="color:#ae81ff">4</span>),A(<span style="color:#ae81ff">5</span>) };
	cout <span style="color:#f92672">&lt;&lt;</span> binary_search(a,a<span style="color:#f92672">+</span><span style="color:#ae81ff">4</span>,A(<span style="color:#ae81ff">9</span>)); 
	<span style="color:#75715e">//折半查找
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
A a [] <span style="color:#f92672">=</span> { A(<span style="color:#ae81ff">1</span>),A(<span style="color:#ae81ff">2</span>),A(<span style="color:#ae81ff">3</span>),A(<span style="color:#ae81ff">4</span>),A(<span style="color:#ae81ff">5</span>) };
cout <span style="color:#f92672">&lt;&lt;</span> binary_search(a,a<span style="color:#f92672">+</span><span style="color:#ae81ff">4</span>,A(<span style="color:#ae81ff">9</span>));
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#75715e">//输出结果：
</span><span style="color:#75715e">//3&lt;9?
</span><span style="color:#75715e">//2&lt;9?
</span><span style="color:#75715e">//1&lt;9?
</span><span style="color:#75715e">//9&lt;1?
</span><span style="color:#75715e">//1
</span></code></pre></div>
    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
